# Ch 05 索引函數的高階應用

## 變數型態轉換(1)

```
dat = read.csv("comorbidity_2.csv", header = TRUE, fileEncoding = 'CP950')
head(dat, 10)
##    問卷編號 Disease名稱1 Disease名稱2 Disease名稱3
## 1         1                                       
## 2         2       高血壓          C肝             
## 3         3          C肝       腎結石             
## 4         4       高血壓         氣喘         痛風
## 5         5       高血壓                          
## 6         6   腎功能不全                          
## 7         7       高血壓       心臟病             
## 8         8       高血壓       心臟病          B肝
## 9         9       心臟病                          
## 10       10       高血壓       糖尿病
```

- 我們的目標是將檔案轉換成這樣的格式

```
##   ID   BPH B型肝炎   B肝 C型肝炎   C肝  HCVD  HIVD   SLE  中風 冠心病 塵肺症
## 1  1 FALSE   FALSE FALSE   FALSE FALSE FALSE FALSE FALSE FALSE  FALSE  FALSE
## 2  2 FALSE   FALSE FALSE   FALSE  TRUE FALSE FALSE FALSE FALSE  FALSE  FALSE
## 3  3 FALSE   FALSE FALSE   FALSE  TRUE FALSE FALSE FALSE FALSE  FALSE  FALSE
## 4  4 FALSE   FALSE FALSE   FALSE FALSE FALSE FALSE FALSE FALSE  FALSE  FALSE
## 5  5 FALSE   FALSE FALSE   FALSE FALSE FALSE FALSE FALSE FALSE  FALSE  FALSE
## 6  6 FALSE   FALSE FALSE   FALSE FALSE FALSE FALSE FALSE FALSE  FALSE  FALSE
##    失眠 子宮頸癌 小中風 小兒麻痺 心導管 心律不整 心臟病 心血管疾病 憂鬱症
## 1 FALSE    FALSE  FALSE    FALSE  FALSE    FALSE  FALSE      FALSE  FALSE
## 2 FALSE    FALSE  FALSE    FALSE  FALSE    FALSE  FALSE      FALSE  FALSE
## 3 FALSE    FALSE  FALSE    FALSE  FALSE    FALSE  FALSE      FALSE  FALSE
## 4 FALSE    FALSE  FALSE    FALSE  FALSE    FALSE  FALSE      FALSE  FALSE
## 5 FALSE    FALSE  FALSE    FALSE  FALSE    FALSE  FALSE      FALSE  FALSE
## 6 FALSE    FALSE  FALSE    FALSE  FALSE    FALSE  FALSE      FALSE  FALSE
##   攝護腺肥大  氣喘 狹心症 甲狀腺 甲狀腺低下 甲狀腺瘤 甲狀腺癌  痛風 白內障
## 1      FALSE FALSE  FALSE  FALSE      FALSE    FALSE    FALSE FALSE  FALSE
## 2      FALSE FALSE  FALSE  FALSE      FALSE    FALSE    FALSE FALSE  FALSE
## 3      FALSE FALSE  FALSE  FALSE      FALSE    FALSE    FALSE FALSE  FALSE
## 4      FALSE  TRUE  FALSE  FALSE      FALSE    FALSE    FALSE  TRUE  FALSE
## 5      FALSE FALSE  FALSE  FALSE      FALSE    FALSE    FALSE FALSE  FALSE
## 6      FALSE FALSE  FALSE  FALSE      FALSE    FALSE    FALSE FALSE  FALSE
##   糖尿病 耳腫瘤  肝炎  肝癌 肝硬化 胃出血 胃潰瘍  胃炎 胃食道逆流 脊椎有骨刺
## 1  FALSE  FALSE FALSE FALSE  FALSE  FALSE  FALSE FALSE      FALSE      FALSE
## 2  FALSE  FALSE FALSE FALSE  FALSE  FALSE  FALSE FALSE      FALSE      FALSE
## 3  FALSE  FALSE FALSE FALSE  FALSE  FALSE  FALSE FALSE      FALSE      FALSE
## 4  FALSE  FALSE FALSE FALSE  FALSE  FALSE  FALSE FALSE      FALSE      FALSE
## 5  FALSE  FALSE FALSE FALSE  FALSE  FALSE  FALSE FALSE      FALSE      FALSE
## 6  FALSE  FALSE FALSE FALSE  FALSE  FALSE  FALSE FALSE      FALSE      FALSE
##   腎功能不全 腎水泡 腎結石 腎臟疾病 腎臟病 膽固醇 膽固醇過高 膽結石 靜脈曲張
## 1      FALSE  FALSE  FALSE    FALSE  FALSE  FALSE      FALSE  FALSE    FALSE
## 2      FALSE  FALSE  FALSE    FALSE  FALSE  FALSE      FALSE  FALSE    FALSE
## 3      FALSE  FALSE   TRUE    FALSE  FALSE  FALSE      FALSE  FALSE    FALSE
## 4      FALSE  FALSE  FALSE    FALSE  FALSE  FALSE      FALSE  FALSE    FALSE
## 5      FALSE  FALSE  FALSE    FALSE  FALSE  FALSE      FALSE  FALSE    FALSE
## 6       TRUE  FALSE  FALSE    FALSE  FALSE  FALSE      FALSE  FALSE    FALSE
##   類風濕性關節炎 高血壓 高血脂
## 1          FALSE  FALSE  FALSE
## 2          FALSE   TRUE  FALSE
## 3          FALSE  FALSE  FALSE
## 4          FALSE   TRUE  FALSE
## 5          FALSE   TRUE  FALSE
## 6          FALSE  FALSE  FALSE
```

# 變數型態轉換(2)

- 承上週，我們非常需要「levels」與「factor」的結合。

– 但是如果我們直接合併，我們會出現問題

```
all_disease = c(dat[,2], dat[,3], dat[,4])
lvl.disease = levels(factor(all_disease))
lvl.disease
```

- 出現這樣的問題，主要是因為因子向量內其實有一個「字典」，而這個「字典」其實是沒辦法合併的。

# 變數型態轉換(3)

- 因此，我們必須先轉換成文字格式才能合併

```
dat[,2] = as.character(dat[,2])
dat[,3] = as.character(dat[,3])
dat[,4] = as.character(dat[,4])

all_disease = c(dat[,2], dat[,3], dat[,4])
lvl.disease = levels(factor(all_disease))
```

– 或者是，在讀檔時直接把文字讀成非因子格式

```
dat = read.csv("comorbidity_2.csv", header = TRUE, fileEncoding = 'CP950', stringsAsFactors = FALSE)

all_disease = c(dat[,2], dat[,3], dat[,4])
lvl.disease = levels(factor(all_disease))
```

# 變數型態轉換(4)

- 資料轉換的重點只有一個，那就是先想好目標格式，接著利用迴圈功能一格一格把目標格式的資料填滿

– 當然，之後也許你會看到一些函數能加速整個流程，但在面對小筆資料時熟練的使用迴圈能幫忙我們迅速做完資料轉換

- 現在有了字典後，我們就能開一個空矩陣一個一個人填入：

```
dat = read.csv("comorbidity_2.csv", header = TRUE, fileEncoding = 'CP950', stringsAsFactors = FALSE)

all_disease = c(dat[,2], dat[,3], dat[,4])
lvl.disease = levels(factor(all_disease))

lvl.disease = lvl.disease[-1]
lvl.sample = levels(factor(dat[,1]))

new.dat = matrix(0, nrow = length(lvl.sample), ncol = length(lvl.disease)+1)
colnames(new.dat) = c("ID", lvl.disease)
new.dat[,1] = lvl.sample 
```

- 讓我們看看第一個人的疾病狀態

```
i = 1
dat[dat[,1]==lvl.sample[i],2:4]
##   Disease名稱1 Disease名稱2 Disease名稱3
## 1
```

- 同樣的，用「%in%」可以幫忙我們得到他是否有每一個疾病

```
lvl.disease %in% dat[dat[,1]==lvl.sample[i],2:4]
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [49] FALSE FALSE FALSE
```

- 接著，我們要把這些值填入矩陣的第1列，但第一欄除外(因為第一欄是ID)，我們可以使用負數代表除去不想要的欄位

```
new.dat[i,-1] = lvl.disease %in% dat[dat[,1]==lvl.sample[i],2:4]
```

- 包成迴圈！

```
lvl.disease = lvl.disease[-1]
lvl.sample = levels(factor(dat[,1]))

new.dat = matrix(0, nrow = length(lvl.sample), ncol = length(lvl.disease)+1)
colnames(new.dat) = c("ID", lvl.disease)
new.dat[,1] = lvl.sample 

for (i in 1:length(lvl.disease)) {
  new.dat[i,-1] = lvl.disease %in% dat[dat[,1]==lvl.sample[i],2:4]
}
new.dat = data.frame(new.dat)

new.dat
```

# 資料轉換概念(1)

從三軍總醫院生化檢驗值系統截取某10位病患在這段期間內所測得之各式生化值

```
dat = read.csv("laboratory_1.csv", header = TRUE, fileEncoding = 'CP950')
head(dat, 10)
##    PATNUMBER          COLLECTIONDATE      TESTNAME RESVALUE
## 1       2185 2011/12/12 上午 8:09:00    Creatinine      7.0
## 2       2185 2011/12/12 上午 8:09:00 Total Calcium      7.1
## 3       2185 2011/12/12 上午 8:09:00            Na    137.0
## 4       2185 2011/12/12 上午 8:09:00            IP      7.9
## 5        691 2011/12/12 下午 6:32:00    Creatinine      3.1
## 6       2185 2011/12/29 上午 6:19:00    Creatinine      7.2
## 7       2185 2011/12/29 上午 6:19:00            Na    136.0
## 8        691 2011/12/19 上午 4:38:00    Creatinine      8.0
## 9        691 2011/12/19 上午 4:38:00            Na    137.0
## 10      2185 2011/12/19 上午 8:47:00    Creatinine      8.1
```

- 我們希望能把資料轉換成這樣的格式

```
##      PATNUMBER COLLECTIONDATE            Albumin Albumin body fluid AST BUN
## [1,] "175"     "2011/10/1 上午 8:24:00"  NA      NA                 NA  NA 
## [2,] "175"     "2011/10/5 下午 4:46:00"  NA      NA                 NA  NA 
## [3,] "175"     "2011/10/6 上午 9:01:00"  NA      NA                 NA  NA 
## [4,] "175"     "2011/10/8 上午 6:42:00"  NA      NA                 NA  NA 
## [5,] "175"     "2011/11/10 上午 9:01:00" NA      NA                 NA  NA 
## [6,] "175"     "2011/11/10 下午 1:25:00" NA      NA                 NA  NA 
##      BUN Fluid Cholesterol Fluid Creatinine Creatinine Fluid GLU(AC)
## [1,] NA        NA                "3.7"      NA               NA     
## [2,] NA        NA                "3.2"      NA               NA     
## [3,] NA        NA                NA         NA               NA     
## [4,] NA        NA                "3.4"      NA               NA     
## [5,] NA        NA                NA         NA               NA     
## [6,] NA        NA                NA         NA               NA     
##      HDL-Cholesterol IP    K  LDL-Cholesterol Na    Total Calcium
## [1,] NA              "4.3" NA NA              "138" "7.3"        
## [2,] NA              NA    NA NA              "139" NA           
## [3,] NA              "4.5" NA NA              NA    "7.8"        
## [4,] NA              NA    NA NA              NA    NA           
## [5,] NA              "4.5" NA NA              NA    "7.3"        
## [6,] NA              NA    NA NA              NA    NA           
##      Total Cholesterol Triglyceride Triglycerol Fluid Uric Acid urine Calcium
## [1,] NA                NA           NA                NA        NA           
## [2,] NA                NA           NA                NA        NA           
## [3,] "342"             "335"        NA                NA        NA           
## [4,] NA                NA           NA                NA        NA           
## [5,] "342"             "326"        NA                NA        NA           
## [6,] NA                NA           NA                NA        "0.6"        
##      urine Phosphorus urine Potassium urine Sodium urine Uric Acid
## [1,] NA               NA              NA           NA             
## [2,] NA               NA              NA           NA             
## [3,] NA               NA              NA           NA             
## [4,] NA               NA              NA           NA             
## [5,] NA               NA              NA           NA             
## [6,] "28.3"           "39.1"          "48"         NA
```

# 資料轉換概念(2)

- 現在這筆資料在轉換時有2個維度，分別是「個案」及「測量時間」，我們在最開始規畫的時候要先把東西盡可能拆離成小部分，最後再用迴圈功能一口氣全部做完

– 一樣，先取得這份資料的基本資訊

```
levels.TESTNAME = levels(dat[,3])
levels.TESTNAME
##  [1] "Albumin"            "Albumin body fluid" "AST"               
##  [4] "BUN"                "BUN Fluid"          "Cholesterol Fluid" 
##  [7] "Creatinine"         "Creatinine Fluid"   "GLU(AC)"           
## [10] "HDL-Cholesterol"    "IP"                 "K"                 
## [13] "LDL-Cholesterol"    "Na"                 "Total Calcium"     
## [16] "Total Cholesterol"  "Triglyceride"       "Triglycerol Fluid" 
## [19] "Uric Acid"          "urine Calcium"      "urine Phosphorus"  
## [22] "urine Potassium"    "urine Sodium"       "urine Uric Acid"
n.TESTNAME = length(levels.TESTNAME)
n.TESTNAME
## [1] 24
levels.PATNUMBER = levels(as.factor(dat[,1]))
levels.PATNUMBER
##  [1] "175"  "356"  "691"  "1332" "1350" "1654" "1826" "2074" "2154" "2185"
n.PATNUMBER = length(levels.PATNUMBER)
n.PATNUMBER
## [1] 10
```

# 資料轉換概念(3)

- 我們只先做一個個案，之後再想辦法利用迴圈把它全部都做完就好

– 在寫迴圈時，我習慣先在起頭令迴圈變數為1，如果這段以後能執行，那應該整個迴圈都不會有問題

- 我們先把個案1的資料先切割出來

```
i = 1
subdat = dat[dat[,1]==levels.PATNUMBER[i],]
```

- 接著，我們再取得subdat中的一些資訊，主要就是他總共測了幾次

```
levels.COLLECTIONDATE = levels(subdat[,2])
n.COLLECTIONDATE = length(levels.COLLECTIONDATE)
n.COLLECTIONDATE
## [1] 1532
```

- 有沒有發現他好像測量太多次了？這是因為我們將檔案切割成subdat時，第二欄的因子向量仍然記得他以前有多少個類別，因此我們要先把它的記憶洗掉。洗掉的方法有很多種，如先轉換成文字向量，再轉換回因子向量

```
subdat[,2] = as.factor(as.character(subdat[,2]))
levels.COLLECTIONDATE = levels(subdat[,2])
n.COLLECTIONDATE = length(levels.COLLECTIONDATE)
n.COLLECTIONDATE
## [1] 132
```

# 資料轉換概念(4)

- 接著，我們先建立一個矩陣讓我們填資料

– 第一欄填ID，第二欄填上這個人所有測量的時間點

```
submatrix = matrix(NA, nrow = n.COLLECTIONDATE, ncol = n.TESTNAME+2)
colnames(submatrix) = c("PATNUMBER", "COLLECTIONDATE", levels.TESTNAME)

submatrix[,1] = levels.PATNUMBER[i]
submatrix[,2] = levels.COLLECTIONDATE

head(submatrix)
##      PATNUMBER COLLECTIONDATE            Albumin Albumin body fluid AST BUN
## [1,] "175"     "2011/10/1 上午 8:24:00"  NA      NA                 NA  NA 
## [2,] "175"     "2011/10/5 下午 4:46:00"  NA      NA                 NA  NA 
## [3,] "175"     "2011/10/6 上午 9:01:00"  NA      NA                 NA  NA 
## [4,] "175"     "2011/10/8 上午 6:42:00"  NA      NA                 NA  NA 
## [5,] "175"     "2011/11/10 上午 9:01:00" NA      NA                 NA  NA 
## [6,] "175"     "2011/11/10 下午 1:25:00" NA      NA                 NA  NA 
##      BUN Fluid Cholesterol Fluid Creatinine Creatinine Fluid GLU(AC)
## [1,] NA        NA                NA         NA               NA     
## [2,] NA        NA                NA         NA               NA     
## [3,] NA        NA                NA         NA               NA     
## [4,] NA        NA                NA         NA               NA     
## [5,] NA        NA                NA         NA               NA     
## [6,] NA        NA                NA         NA               NA     
##      HDL-Cholesterol IP K  LDL-Cholesterol Na Total Calcium Total Cholesterol
## [1,] NA              NA NA NA              NA NA            NA               
## [2,] NA              NA NA NA              NA NA            NA               
## [3,] NA              NA NA NA              NA NA            NA               
## [4,] NA              NA NA NA              NA NA            NA               
## [5,] NA              NA NA NA              NA NA            NA               
## [6,] NA              NA NA NA              NA NA            NA               
##      Triglyceride Triglycerol Fluid Uric Acid urine Calcium urine Phosphorus
## [1,] NA           NA                NA        NA            NA              
## [2,] NA           NA                NA        NA            NA              
## [3,] NA           NA                NA        NA            NA              
## [4,] NA           NA                NA        NA            NA              
## [5,] NA           NA                NA        NA            NA              
## [6,] NA           NA                NA        NA            NA              
##      urine Potassium urine Sodium urine Uric Acid
## [1,] NA              NA           NA             
## [2,] NA              NA           NA             
## [3,] NA              NA           NA             
## [4,] NA              NA           NA             
## [5,] NA              NA           NA             
## [6,] NA              NA           NA
```

- 接著，我們開始能一個時間點一個時間點分析了，我們能把subdat在切割出更細的subsubdat

– 同樣的，我們先看第一個時間點，注意迴圈變數不要重複，所以剛剛設i，這次我們設j

```
j = 1
subsubdat = subdat[subdat[,2]==levels.COLLECTIONDATE[j],]
subsubdat
##      PATNUMBER         COLLECTIONDATE      TESTNAME RESVALUE
## 3993       175 2011/10/1 上午 8:24:00            IP      4.3
## 3994       175 2011/10/1 上午 8:24:00 Total Calcium      7.3
## 3995       175 2011/10/1 上午 8:24:00    Creatinine      3.7
## 3996       175 2011/10/1 上午 8:24:00            Na    138.0
```

# 資料轉換概念(5)

- 我們需要這份小資料中每列都執行下列的事項

1. 找出這列是描述哪個生化值
2. 找出在submatrix中這個生化值的位置
3. 把value填入那個位置

- 同樣，我們可以再開一個迴圈執行這個部分，這次這個迴圈的迴圈變數命為k

– 函數「which()」可以幫我們找位置

```
k = 1
NAME = subsubdat[k,3]
NAME
## [1] IP
## 24 Levels: Albumin Albumin body fluid AST BUN BUN Fluid ... urine Uric Acid
position = which(NAME == levels.TESTNAME) + 2 
position
## [1] 13
submatrix[j, position] = subsubdat[k,4]
head(submatrix)
##      PATNUMBER COLLECTIONDATE            Albumin Albumin body fluid AST BUN
## [1,] "175"     "2011/10/1 上午 8:24:00"  NA      NA                 NA  NA 
## [2,] "175"     "2011/10/5 下午 4:46:00"  NA      NA                 NA  NA 
## [3,] "175"     "2011/10/6 上午 9:01:00"  NA      NA                 NA  NA 
## [4,] "175"     "2011/10/8 上午 6:42:00"  NA      NA                 NA  NA 
## [5,] "175"     "2011/11/10 上午 9:01:00" NA      NA                 NA  NA 
## [6,] "175"     "2011/11/10 下午 1:25:00" NA      NA                 NA  NA 
##      BUN Fluid Cholesterol Fluid Creatinine Creatinine Fluid GLU(AC)
## [1,] NA        NA                NA         NA               NA     
## [2,] NA        NA                NA         NA               NA     
## [3,] NA        NA                NA         NA               NA     
## [4,] NA        NA                NA         NA               NA     
## [5,] NA        NA                NA         NA               NA     
## [6,] NA        NA                NA         NA               NA     
##      HDL-Cholesterol IP    K  LDL-Cholesterol Na Total Calcium
## [1,] NA              "4.3" NA NA              NA NA           
## [2,] NA              NA    NA NA              NA NA           
## [3,] NA              NA    NA NA              NA NA           
## [4,] NA              NA    NA NA              NA NA           
## [5,] NA              NA    NA NA              NA NA           
## [6,] NA              NA    NA NA              NA NA           
##      Total Cholesterol Triglyceride Triglycerol Fluid Uric Acid urine Calcium
## [1,] NA                NA           NA                NA        NA           
## [2,] NA                NA           NA                NA        NA           
## [3,] NA                NA           NA                NA        NA           
## [4,] NA                NA           NA                NA        NA           
## [5,] NA                NA           NA                NA        NA           
## [6,] NA                NA           NA                NA        NA           
##      urine Phosphorus urine Potassium urine Sodium urine Uric Acid
## [1,] NA               NA              NA           NA             
## [2,] NA               NA              NA           NA             
## [3,] NA               NA              NA           NA             
## [4,] NA               NA              NA           NA             
## [5,] NA               NA              NA           NA             
## [6,] NA               NA              NA           NA
```

# 資料轉換概念(6)

- 現在，我們可以將要對subsubdat中所做的事情打包成一個迴圈如下，這樣第一個時間點就完成了

```
subsubdat #先看看subsubdat裡面有哪些
##      PATNUMBER         COLLECTIONDATE      TESTNAME RESVALUE
## 3993       175 2011/10/1 上午 8:24:00            IP      4.3
## 3994       175 2011/10/1 上午 8:24:00 Total Calcium      7.3
## 3995       175 2011/10/1 上午 8:24:00    Creatinine      3.7
## 3996       175 2011/10/1 上午 8:24:00            Na    138.0
for (k in 1:nrow(subsubdat)) {
  NAME = subsubdat[k,3]
  position = which(NAME == levels.TESTNAME) + 2
  submatrix[j, position] = subsubdat[k,4]
}
head(submatrix)
```

# 資料轉換概念(7)

- 由於這是一個人中一個時間點的迴圈，我們可以把一整個迴圈打包在另一個迴圈之下

```
for (j in 1:n.COLLECTIONDATE) {
  subsubdat = subdat[subdat[,2]==levels.COLLECTIONDATE[j],]
  for (k in 1:nrow(subsubdat)) {
    NAME = subsubdat[k,3]
    position = which(NAME == levels.TESTNAME) + 2
    submatrix[j, position] = subsubdat[k,4]
  }
}

head(submatrix)
##      PATNUMBER COLLECTIONDATE            Albumin Albumin body fluid AST BUN
## [1,] "175"     "2011/10/1 上午 8:24:00"  NA      NA                 NA  NA 
## [2,] "175"     "2011/10/5 下午 4:46:00"  NA      NA                 NA  NA 
## [3,] "175"     "2011/10/6 上午 9:01:00"  NA      NA                 NA  NA 
## [4,] "175"     "2011/10/8 上午 6:42:00"  NA      NA                 NA  NA 
## [5,] "175"     "2011/11/10 上午 9:01:00" NA      NA                 NA  NA 
## [6,] "175"     "2011/11/10 下午 1:25:00" NA      NA                 NA  NA 
##      BUN Fluid Cholesterol Fluid Creatinine Creatinine Fluid GLU(AC)
## [1,] NA        NA                "3.7"      NA               NA     
## [2,] NA        NA                "3.2"      NA               NA     
## [3,] NA        NA                NA         NA               NA     
## [4,] NA        NA                "3.4"      NA               NA     
## [5,] NA        NA                NA         NA               NA     
## [6,] NA        NA                NA         NA               NA     
##      HDL-Cholesterol IP    K  LDL-Cholesterol Na    Total Calcium
## [1,] NA              "4.3" NA NA              "138" "7.3"        
## [2,] NA              NA    NA NA              "139" NA           
## [3,] NA              "4.5" NA NA              NA    "7.8"        
## [4,] NA              NA    NA NA              NA    NA           
## [5,] NA              "4.5" NA NA              NA    "7.3"        
## [6,] NA              NA    NA NA              NA    NA           
##      Total Cholesterol Triglyceride Triglycerol Fluid Uric Acid urine Calcium
## [1,] NA                NA           NA                NA        NA           
## [2,] NA                NA           NA                NA        NA           
## [3,] "342"             "335"        NA                NA        NA           
## [4,] NA                NA           NA                NA        NA           
## [5,] "342"             "326"        NA                NA        NA           
## [6,] NA                NA           NA                NA        "0.6"        
##      urine Phosphorus urine Potassium urine Sodium urine Uric Acid
## [1,] NA               NA              NA           NA             
## [2,] NA               NA              NA           NA             
## [3,] NA               NA              NA           NA             
## [4,] NA               NA              NA           NA             
## [5,] NA               NA              NA           NA             
## [6,] "28.3"           "39.1"          "48"         NA
```

# 資料轉換概念(8)

- 現在我們整理一下對於第一個人所使用到的所有程式碼，接著我們即將要讓電腦重複10次(因為有10個人)

– 下列這串程式碼可以獲得一個完整的submatrix

```
i = 1

subdat = dat[dat[,1]==levels.PATNUMBER[i],]
subdat[,2] = as.factor(as.character(subdat[,2]))
levels.COLLECTIONDATE = levels(subdat[,2])
n.COLLECTIONDATE = length(levels.COLLECTIONDATE)
n.COLLECTIONDATE

submatrix = matrix(NA, nrow = n.COLLECTIONDATE, ncol = n.TESTNAME+2)
colnames(submatrix) = c("PATNUMBER", "COLLECTIONDATE", levels.TESTNAME)

submatrix[,1] = levels.PATNUMBER[i]
submatrix[,2] = levels.COLLECTIONDATE

for (j in 1:n.COLLECTIONDATE) {
  subsubdat = subdat[subdat[,2]==levels.COLLECTIONDATE[j],]
  for (k in 1:nrow(subsubdat)) {
    NAME = subsubdat[k,3]
    position = which(NAME == levels.TESTNAME) + 2
    submatrix[j, position] = subsubdat[k,4]
  }
}
```

- 然而，我們必須要把submatrix寫出到完整的大表，否則i只要一改變，將會重新建立一個新的submatrix，我們可以透過函數「rbind()」完成，但在最開始的時候甚麼東西都沒有，所以我們要先令一個東西起始為NULL，然後這個東西會隨著迴圈不斷地長大

```
final.data = NULL
final.data
## NULL
final.data = rbind(final.data, submatrix)
head(final.data)
##      PATNUMBER COLLECTIONDATE            Albumin Albumin body fluid AST BUN
## [1,] "175"     "2011/10/1 上午 8:24:00"  NA      NA                 NA  NA 
## [2,] "175"     "2011/10/5 下午 4:46:00"  NA      NA                 NA  NA 
## [3,] "175"     "2011/10/6 上午 9:01:00"  NA      NA                 NA  NA 
## [4,] "175"     "2011/10/8 上午 6:42:00"  NA      NA                 NA  NA 
## [5,] "175"     "2011/11/10 上午 9:01:00" NA      NA                 NA  NA 
## [6,] "175"     "2011/11/10 下午 1:25:00" NA      NA                 NA  NA 
##      BUN Fluid Cholesterol Fluid Creatinine Creatinine Fluid GLU(AC)
## [1,] NA        NA                "3.7"      NA               NA     
## [2,] NA        NA                "3.2"      NA               NA     
## [3,] NA        NA                NA         NA               NA     
## [4,] NA        NA                "3.4"      NA               NA     
## [5,] NA        NA                NA         NA               NA     
## [6,] NA        NA                NA         NA               NA     
##      HDL-Cholesterol IP    K  LDL-Cholesterol Na    Total Calcium
## [1,] NA              "4.3" NA NA              "138" "7.3"        
## [2,] NA              NA    NA NA              "139" NA           
## [3,] NA              "4.5" NA NA              NA    "7.8"        
## [4,] NA              NA    NA NA              NA    NA           
## [5,] NA              "4.5" NA NA              NA    "7.3"        
## [6,] NA              NA    NA NA              NA    NA           
##      Total Cholesterol Triglyceride Triglycerol Fluid Uric Acid urine Calcium
## [1,] NA                NA           NA                NA        NA           
## [2,] NA                NA           NA                NA        NA           
## [3,] "342"             "335"        NA                NA        NA           
## [4,] NA                NA           NA                NA        NA           
## [5,] "342"             "326"        NA                NA        NA           
## [6,] NA                NA           NA                NA        "0.6"        
##      urine Phosphorus urine Potassium urine Sodium urine Uric Acid
## [1,] NA               NA              NA           NA             
## [2,] NA               NA              NA           NA             
## [3,] NA               NA              NA           NA             
## [4,] NA               NA              NA           NA             
## [5,] NA               NA              NA           NA             
## [6,] "28.3"           "39.1"          "48"         NA
```

# Ch 06 列表簡介與應用

## 列表(List)層物件基本介紹(1)

你有注意到的話，迴圈運行速度其實是越來越慢，這個問題其實是出在我們的函數「rbind」，這個函數雖然能夠方便的把兩個資料表合併成一個，但他的過程其實對記憶體很不友善的！

- 為了解決這個問題，讓我們先學一個新的物件格式：列表

– 列表(List)層分為列表(list)、S3物件(S3 class)及S4物件(S4 class)：

1. 列表(list)：在R裡面，向量的上層是陣列層物件。若是我們希望在一個物件內放置很多陣列層物件，我們會用到列表。値得一提的是，列表裡面可以同時包含數個陣列層物件及變數層物件。
2. S3物件(S3 class)：S3物件是一種特殊的列表物件，他的變化會在後面慢慢介紹。
3. S4物件(S4 class)：S4物件與前面兩種有非常大的不同，相關的函數也不一樣，在本節課我們不會教到。

- 我們首先介紹列表(list)物件

```
# 先產生一個數値矩陣物件
x1 = 1:20
M1 = matrix(x1, nrow = 4, ncol = 5)
M1
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
# 再產生一個文字矩陣物件
x2 = c("A", "B", "C", "A", "C", "B", "B", "B", "A")
M2 = matrix(x2, nrow = 3, ncol = 3)
M2
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A"
# 再產生一個邏輯向量
x3 = c(TRUE, FALSE, TRUE, FALSE)
x3
## [1]  TRUE FALSE  TRUE FALSE
# 將上述這些物件打包成一個列表物件
L1 = list(M1, M2, x3)
L1
## [[1]]
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
## 
## [[2]]
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A" 
## 
## [[3]]
## [1]  TRUE FALSE  TRUE FALSE
```

# 列表(List)層物件基本介紹(2)

- 列表(List)層物件中有幾個重要的函數來描述它的基本資料：

1. 函數「length()」可以協助我們了解物件長度
2. 函數「class()」可以查詢該物件的屬性
3. 函數「names()」可以協助我們命名物件
4. 函數「ls()」可以協助我們看看物件中有哪些東西

```
length(L1)
## [1] 3
class(L1)
## [1] "list"
names(L1) = c("A", "B", "C")
L1
## $A
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
## 
## $B
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A" 
## 
## $C
## [1]  TRUE FALSE  TRUE FALSE
ls(L1)
## [1] "A" "B" "C"
```

# 列表(List)層物件基本介紹(3)

- 在R裡面所有的索引函數都由中括號形成，列表(List)層物件中的索引函數是使用[[]]，我們直接在中括號內填入數字就好。另外，索引函數「$」一樣能用在陣列層的物件

```
L1[[2]]
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A"
L1[["B"]]
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A"
L1$B
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A"
```

- 如果我們想要進一步再找藏在L1裡面的B裡面的元素，我們可以繼續使用索引函數

```
L1[[2]][2,3]
## [1] "B"
L1[["B"]][3,1]
## [1] "C"
L1$B[1,2]
## [1] "A"
```

# 列表(List)層物件基本介紹(4)

- 經過了上述的示範後，我們了解到列表(list)是一個很方便的物件，它可以把很多很雜的東西丟在同個物件內。但東西多了以後會遇到問題，那就是該列表物件會變的非常非常大，但也許我們想要呈現的東西是很有限的，在R裡面，列表有一種擴展型態叫做S3物件(S3 class)，它可以解決這個問題。
- S3物件(S3 class)的產生方式如下

```
#先看看L1的樣子
L1
## $A
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
## 
## $B
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A" 
## 
## $C
## [1]  TRUE FALSE  TRUE FALSE
#先看看L1的物件屬性
class(L1)
## [1] "list"
#強迫L1成為別的物件屬性
class(L1) = "test"
#再看看L1的物件屬性
class(L1)
## [1] "test"
#看看L1現在的樣子
L1
## $A
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
## 
## $B
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "B" 
## [3,] "C"  "B"  "A" 
## 
## $C
## [1]  TRUE FALSE  TRUE FALSE
## 
## attr(,"class")
## [1] "test"
```

– 小提示：當你使用函數「class()」可以查詢該物件的屬性，若非常見的幾種屬性名稱，那就非常有可能是S3物件(S3 class)或S4物件(S4 class).

# 列表(List)層物件基本介紹(5)

- 轉變為S3物件(S3 class)後，我們可以透過自訂函數「print.XXX()」、自訂函數「summary.XXX()」等函數來讓R知道要如何呈現這個S3物件

```
#先寫一個自訂函數「print.test()」
print.test = function(test) {
  cat("此列表共有",length(test),"個物件\n")
  cat("物件名稱分別為：\n")
  cat(paste(names(test), collapse = ", "), "\n")
}

#再看看請R列印出L1會變什麼
L1
## 此列表共有 3 個物件
## 物件名稱分別為：
## A, B, C
```

– 列表(list)的幾個常見函數還是能夠使用：

```
ls(L1)
## [1] "A" "B" "C"
length(L1)
## [1] 3
class(L1)
## [1] "test"
names(L1) = c("D", "E", "F")
L1
## 此列表共有 3 個物件
## 物件名稱分別為：
## D, E, F
```

# 列表(List)層物件基本介紹(6)

- 接著我們還能寫自訂函數「summary.XXX()」來呈現更詳細的資料

– 在寫之前我們先看看直接對L1使用函數「summary()」會怎樣

```
summary(L1)
##   Length Class  Mode     
## D 20     -none- numeric  
## E  9     -none- character
## F  4     -none- logical
```

– 現在我們可以讓函數「summary()」使用後產生不同的結果

```
#先寫一個自訂函數「summary.test()」
summary.test = function(test) {
  cat("此列表共有",length(test),"個物件\n")
  cat("物件名稱分別為：\n")
  cat(paste(names(test), collapse = ", "), "\n")
  for (i in 1:length(test)) {
    cat(names(test)[i], "之物件屬性為", class(test[[i]]), "\n")
  }
}

#再看看使用函數「summary()」後會變什麼
summary(L1)
## 此列表共有 3 個物件
## 物件名稱分別為：
## D, E, F 
## D 之物件屬性為 matrix 
## E 之物件屬性為 matrix 
## F 之物件屬性為 logical
```

- 會如何將想要的資訊放在列表(list)物件中，並透過將這個物件轉換為一個特定的S3物件(S3 class) 後，就可以透過自訂函數「print.XXX()」呈現想要的結果。
- 我們現在希望能把這個列表轉為S3物件，並且讓他的輸出改為這種格式：

```
Test_list = list(student = c('小明', '小華', '小愛'),
                 score = c(80, 90, 75))

class(Test_list) = 'My_list'

print.My_list = function(Test_list) {
  for (i in 1:length(Test_list[[1]])) {
    cat(Test_list[[1]][i], "的分數為", Test_list[[2]][i], "\n")
  }
}

Test_list
## $student
## [1] "小明" "小華" "小愛"
## 
## $score
## [1] 80 90 75
```

- 假設你學會了編寫S3物件，那直接打出Test_list將會出現下列描述：

```
Test_list
## 小明 的分數為 80 
## 小華 的分數為 90 
## 小愛 的分數為 75
```

# 用列表特性加速任務(1)

- 上一節課我們有發現了函數「rbind」對記憶體很不友善的！

– 讓我們做個小測試，假設我們不斷的將一個完全相同的資料表用rbind指令合併，和先使用列表儲存，看看時間差異有多大：

– 這是連續合併1000次的耗時：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
final_dat = NULL

for (i in 1:1000) {
  
  final_dat = rbind(final_dat, base_dat)
  
}

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 0.3860843 secs
```

– 這是連續合併2000次的耗時：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
final_dat = NULL

for (i in 1:2000) {
  
  final_dat = rbind(final_dat, base_dat)
  
}

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 1.588761 secs
```

– 這是連續合併4000次的耗時：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
final_dat = NULL

for (i in 1:4000) {
  
  final_dat = rbind(final_dat, base_dat)
  
}

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 8.261805 secs
```

- 你似乎發現了一件事情，耗時似乎並非線性成長。

# 用列表特性加速任務(2)

- 讓我們用列表來解決這個問題吧！

– 這是連續合併1000次的耗時：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
dat_list = list()

for (i in 1:1000) {
  
  dat_list[[i]] = base_dat
  
}

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 0.006219149 secs
```

– 這是連續合併2000次的耗時：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
dat_list = list()

for (i in 1:2000) {
  
  dat_list[[i]] = base_dat
  
}

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 0.006496668 secs
```

– 這是連續合併4000次的耗時：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
dat_list = list()

for (i in 1:4000) {
  
  dat_list[[i]] = base_dat
  
}

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 0.007715464 secs
```

- 你發現了嗎?兩者的速度完全不是能比較的！

# 用列表特性加速任務(3)

- 但這樣還遠遠不夠，我們還是需要把這個列表合併成同一個資料表，我們該怎麼做呢?
- 請在[這裡](https://linchin.ndmctsgh.edu.tw/data/laboratory_2.csv)下載資料

– 但這裡需要用到函數「do.call」，他的用法是把list裡面的物件當作參數：

```
dat1 = read.csv("laboratory_2.csv", header = TRUE, fileEncoding = 'CP950')
param_list = list(file = "laboratory_2.csv", header = TRUE, fileEncoding = 'CP950')
dat2 = do.call("read.csv", param_list)
all.equal(dat1, dat2)
## [1] TRUE
```

– 函數「rbind」與函數「do.call」的搭配將能完成任務：

```
t0 = Sys.time()

base_dat = data.frame(X = rnorm(20), Y = rnorm(20))
dat_list = list()

for (i in 1:4000) {
  
  dat_list[[i]] = base_dat
  
}

my_data = do.call("rbind", dat_list)

Sys.time() - t0 #用現在時間減去開始時間
## Time difference of 0.1262248 secs
```

- 這個my_data的結構就如同我們所想的那樣！

```
nrow(my_data)
## [1] 80000
head(my_data)
##             X          Y
## 1  0.14226899 -0.7272419
## 2 -0.61010852  2.3682651
## 3 -0.04489173  0.2426155
## 4  0.98061624  1.3891229
## 5  0.52803578  0.6951405
## 6 -0.33132006 -0.3813124
```

# Ch 07 資料清理及簡易驗證規則

# 資料清理(1)

- 在拿到一筆資料時，第一件事情應該是做資料清理(或稱品質控制)。我們需要先把資料中不應該出現的值給去除，接著再進行分析。

– 一般來說，資料進來以後我們會設定驗證規則，如果不符合此一規則就刪除或重新檢視。

- 驗證規則主要分為下列幾種：

1. 不正確的數據(Incorrect data)：如年齡>130歲
2. 不準確的數據(Inaccurate data)：如年齡實際為50歲的人，被紀錄為60歲
3. 重複的數據(Duplicate data)：如重複key-in的問卷
4. 不完整的數據(Incomplete data)：不該遺漏而遺漏的數據
5. 不一致的數據(Inconsistent data)：如洗腎患者腎絲球過濾率卻有90 ml/min/1.73m2
6. 違反規則(Rule violations)：如收案日期為2010年以前，卻出現2013年的資料

- 在某些領域中，一間公司能否賺錢的重點並非使用多新的統計分析，其最重要的核心價值可能是在資料清理。這時候若你的驗證規則設定的夠仔細，這樣出錯的機率就較低。

# 資料清理(2)

- 我們現在使用一個CKD門診衛教計劃的範例資料，請在[這裡](https://linchin.ndmctsgh.edu.tw/data/validated_example.csv)下載範例資料。

– 這個資料是由門診護理師Key-in填入，按照計劃目標，所有病人每2個月追蹤一次(低於2個月不能給補助)。

– 現在你是腎臟醫學會核發衛教補助的承辦人員，你希望了解一下哪些紀錄是有問題的，而找到這些紀錄後你將要通知該醫院的門診護理師，請他再查閱紙本資料後重新Key-in

- 一樣，我們先讀檔進來

```
dat = read.csv("validated_example.csv", header = TRUE, fileEncoding = 'CP950') 
head(dat)
##   Patient       Date MDRD.GFR Stage   WBC  RBC  HB  Hct  MCV Urea.Nitrogen
## 1    1472  2011/5/31     15.9     4 10.10 2.76 8.7 27.0 98.0            75
## 2    1472   2011/8/8     24.0     4  5.79 1.80 5.7 17.9 99.4            41
## 3    1472 2011/10/17     22.7     4  5.20 2.44 7.8 23.0 94.3            49
## 4    1472  2012/1/10     18.7     4 12.99 2.95 9.4 28.2 95.6            46
## 5    1472  2013/5/14     30.4     3  6.78 3.02 9.7 30.0 99.3            48
## 6    1472  2013/8/22     26.8     4  6.88 3.73 8.6 26.0 95.2            82
##   Creatinine Uric.Acid  Na   K Albumin
## 1        3.0       3.9 139 3.3     4.2
## 2        2.1       4.8 143 4.6     4.2
## 3        2.2       4.7 146 4.8     4.5
## 4        2.6       4.0 141 4.2     4.6
## 5        1.7       3.9 141 4.4     4.1
## 6        1.9       3.0 138 4.1     4.3
```

# 資料清理(3)

- 首先第一步，我們先檢查日期格式，在R裡面剛讀進來的檔案中，日期的格式通常最開始被設定為「因子向量」，這時候是很難檢查的。比較簡單的做法是直接將這個變項轉變為「日期向量」，它需要用到函數「as.Date()」：

```
class(dat[,"Date"])
## [1] "factor"
dat$Date = as.Date(dat[,"Date"])
```

- 這個步驟可以確保所有內容都成為「日期格式」，如果有非正確的日期，這時候R就會提出警告，詳見下列範例：

```
test.date = c("2011/01/05", "2011/09/31", "2011/02/29", "2016/02/29")
test.date = as.Date(test.date)
test.date
## [1] "2011-01-05" NA           NA           "2016-02-29"
```

- 因此，在轉換完成後，我們只要確定轉換後的值是否有產生missing value就可以了，我們可以使用函數「is.na()」：

```
dat$Wrong.Date = is.na(dat$Date)
```

- 所以，現在日期格式錯誤的被紀錄起來了，我們可以透過索引函數叫出錯誤的列讓我們看看

```
dat[dat$Wrong.Date == TRUE,]
##    Patient Date MDRD.GFR Stage WBC  RBC   HB  Hct  MCV Urea.Nitrogen Creatinine
## 45     566 <NA>      2.5     5 6.9 2.95  8.9 25.6 86.8           203       21.4
## 68     710 <NA>     22.3     4 9.2 4.13 12.9 38.2 92.6            60        2.3
##    Uric.Acid  Na   K Albumin Wrong.Date
## 45        NA 120 4.2     3.6       TRUE
## 68      11.2 141 4.2     3.9       TRUE
```

- 在這筆資料中，有兩筆錯誤的日期！

# 資料清理(4)

- 我們稍微整理一下規則1的程式碼，老師會把這串程式碼整理成這樣

```
#Read data
dat = read.csv("validated_example.csv", header = TRUE, fileEncoding = 'CP950') 

#Rule 1: check date-format
dat$Date = as.Date(dat[,"Date"])
dat$Wrong.Date = is.na(dat$Date)
#dat[dat$Wrong.Date == TRUE,]

#Rule 2: ...
```

- 接著，我們需要檢查各變項的範圍，我們先從類別變項開始。變項『Stage』是指CKD的期別，共有5個期別，所以我們的第二條規則是先確定是否有錯誤的數値

– 可以利用之前學過的函數「%in%」，還記得怎麼用嗎?

- 下面是精簡的程式碼，函數「!」可以把所有TRUE與FALSE互相調換，所以Wrong.Stage為TRUE的就變成是「不屬於1至5的」

```
dat$Wrong.Stage = !dat$Stage %in% 1:5
```

# 資料清理(5)

- 連續變項的值比較困難一點，我們可以透過簡單的設定區間找出看起來異常的值，如K低於1.5或高於10的我們可以將它找出來

– 索引函數可以幫助我們設定規則，値得注意的是，未來如果我們想要將連續變項『血壓値』轉換為類別變項『高血壓』時，可以透過類似的方式。

```
dat$Wrong.K[dat$K>10 | dat$K<1.5] = TRUE
dat$Wrong.K[dat$K<=10 & dat$K>=1.5] = FALSE
```

- 我們使用同樣的方法列出所有奇怪的值，發現奇怪的地方在哪了嗎?

```
dat[dat$Wrong.K == TRUE, c("Patient", "Date", "Na", "K", "Wrong.K")]
##       Patient       Date  Na   K Wrong.K
## NA         NA       <NA>  NA  NA      NA
## NA.1       NA       <NA>  NA  NA      NA
## NA.2       NA       <NA>  NA  NA      NA
## NA.3       NA       <NA>  NA  NA      NA
## 32       1514 2013-04-23 5.2 139    TRUE
## NA.4       NA       <NA>  NA  NA      NA
## NA.5       NA       <NA>  NA  NA      NA
## NA.6       NA       <NA>  NA  NA      NA
## NA.7       NA       <NA>  NA  NA      NA
## NA.8       NA       <NA>  NA  NA      NA
## NA.9       NA       <NA>  NA  NA      NA
## NA.10      NA       <NA>  NA  NA      NA
## NA.11      NA       <NA>  NA  NA      NA
## NA.12      NA       <NA>  NA  NA      NA
## 75        710 2010-07-22 5.3 139    TRUE
```

- 由於K有一些人是missing的，所以說我們在顯示時不能呈現NA値，可以透過這樣的方式

```
dat[dat$Wrong.K %in% TRUE, c("Patient", "Date", "Na", "K", "Wrong.K")]
##    Patient       Date  Na   K Wrong.K
## 32    1514 2013-04-23 5.2 139    TRUE
## 75     710 2010-07-22 5.3 139    TRUE
```

# 簡易驗證規則(1)

- 接著我們要設定比較複雜的驗證規則。剛剛有說到同一個人每2個月才能申報一次，如果有人太密集了，那就要把他挑出來。

– 先想步驟，好好思考該怎樣做?

- 首先，我們需要先創造一個邏輯向量，長度為個案數，填入TRUE或FALSE表示這個人是否需要被Highlight。

– 讓我們先留下日期正確的資料

```
dat = dat[!dat$Date %in% NA,]
```

– 還記得怎樣了解個案數嗎?可以透過函數「levels()」以及函數「length()」的組合，但在最開始的時候我們要先確定變數『Patient』是否為因子，若不是則必須先轉換為因子

```
class(dat$Patient)
## [1] "integer"
levels.Patient = levels(as.factor(dat$Patient))
n.Patient = length(levels.Patient)
n.Patient
## [1] 17
x = rep(NA, n.Patient)
```

- 接著，我們可以透過迴圈函數，檢查每個人所有的申報日期

– 還記得上一節課如何教大家寫迴圈函數嗎?先令『i = 1』之後再開始

- 我們先抓出第一個病患的data

– 需要特別注意的是，『levels.Patient』是文字向量，而『dat$Patient』則是整數向量，雖然在這個案例中直接檢索是可以的，但最好還是先轉換成同樣的屬性比較不會出錯

– 由於整數轉文字比較不會出錯，所以最好是把『dat$Patient』轉成文字再比較

```
i = 1
subdat = dat[dat$Patient==levels.Patient[i],]
subdat
##   Patient       Date MDRD.GFR Stage WBC RBC  HB  Hct MCV Urea.Nitrogen
## 8      15 2006-06-14     25.3     4  NA  NA 9.2 29.3  NA            45
## 9      15 2006-08-01     26.4     4  NA  NA  NA   NA  NA            40
##   Creatinine Uric.Acid Na  K Albumin Wrong.Date my.Stage Wrong.Stage
## 8        2.7      14.4 NA NA      NA      FALSE        4       FALSE
## 9        2.6       8.0 NA NA      NA      FALSE        4       FALSE
```

# 簡易驗證規則(3)

- 接著，我們要比對日期了，我們可以先排序日期後，再透過後減前計算差距，並把結果儲存成另外一個向量(這裡也可以再做個迴圈)

– 如果個案僅申報一筆資料就不用繼續了，所以必須加入條件判斷

```
i = 1
subdat = dat[dat$Patient==levels.Patient[i],]
n.date = length(subdat$Date)
if (n.date>1) {
  dif = rep(NA, n.date-1)
  for (k in 1:(n.date-1)) {
    dif[k] = subdat$Date[k+1] - subdat$Date[k]
  }
}
dif
## [1] 48
```

- 上述這斷程式碼其實可以透過函數「diff()」獲得同樣的結果，但同學必須了解，即使我們不知道有這個函數，還是能透過迴圈暴力完成他

```
i = 1
subdat = dat[dat$Patient==levels.Patient[i],]
n.date = length(subdat$Date)
if (n.date>1) {
  dif = diff(subdat$Date)
}
dif
## Time difference of 48 days
```

# 簡易驗證規則(4)

- 下一步，我們想要了解有沒有間隔<2個月的，一個比較簡單的想法是檢查差異是否小於60天，並把結果儲存成一個邏輯向量

```
i = 1
subdat = dat[dat$Patient==levels.Patient[i],]
n.date = length(subdat$Date)
if (n.date>1) {
  dif = diff(subdat$Date)
  check = dif < 60
}
check
## [1] TRUE
```

- 只要裡面有TRUE就中獎了，還記得函數「%in%」嗎?左邊的東西只要右邊有出現就會給TRUE：

```
i = 1
subdat = dat[dat$Patient==levels.Patient[i],]
n.date = length(subdat$Date)
if (n.date>1) {
  dif = diff(subdat$Date)
  check = dif < 60
}
TRUE %in% check
## [1] TRUE
```

- 現在，我們能將這個結果儲存在物件「x」內了

```
i = 1
subdat = dat[dat$Patient==levels.Patient[i],]
n.date = length(subdat$Date)
if (n.date>1) {
  dif = diff(subdat$Date)
  check = dif < 60
  x[i] = TRUE %in% check
} else {
  x[i] = FALSE
}
```

# 簡易驗證規則(5)

- 我們可以將這些組合成一個迴圈了，並且把物件「x」整個填滿，完整函數如下

```
levels.Patient = levels(as.factor(dat$Patient))
n.Patient = length(levels.Patient)
x = rep(NA, n.Patient)

for (i in 1:n.Patient) {
  subdat = dat[dat$Patient==levels.Patient[i],]
  n.date = length(subdat$Date)
  if (n.date>1) {
    dif = diff(subdat$Date)
    check = dif < 60
    x[i] = TRUE %in% check
  } else {
    x[i] = FALSE
  }
}

x
##  [1]  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
## [13] FALSE FALSE FALSE FALSE FALSE
```

- 接著，透過索引函數我們就能找出有哪些人有出現間格過短的情形

```
levels.Patient[x]
## [1] "15"  "240" "414" "566" "710"
```

- 最後，增加一個變數，並透過函數「%in%」一口氣把這些人標示出來：

```
dat$Wrong.Date_interval = dat$Patient %in% levels.Patient[x]
```

#  Ch 08 進階驗證篩選與外部套件應用

# 進階驗證篩選(1)

- 上週，我們發現這樣還是沒有辦法「精準的」找到錯誤的筆數，也許整份資料其實只要能夠刪掉幾筆就能成立。

– 我們再使用CKD門診衛教計劃的範例資料，請在[這裡](https://linchin.ndmctsgh.edu.tw/data/validated_example.csv)下載範例資料。

```
dat = read.csv("validated_example.csv", header = TRUE, fileEncoding = 'CP950') 
head(dat)
##   Patient       Date MDRD.GFR Stage   WBC  RBC  HB  Hct  MCV Urea.Nitrogen
## 1    1472  2011/5/31     15.9     4 10.10 2.76 8.7 27.0 98.0            75
## 2    1472   2011/8/8     24.0     4  5.79 1.80 5.7 17.9 99.4            41
## 3    1472 2011/10/17     22.7     4  5.20 2.44 7.8 23.0 94.3            49
## 4    1472  2012/1/10     18.7     4 12.99 2.95 9.4 28.2 95.6            46
## 5    1472  2013/5/14     30.4     3  6.78 3.02 9.7 30.0 99.3            48
## 6    1472  2013/8/22     26.8     4  6.88 3.73 8.6 26.0 95.2            82
##   Creatinine Uric.Acid  Na   K Albumin
## 1        3.0       3.9 139 3.3     4.2
## 2        2.1       4.8 143 4.6     4.2
## 3        2.2       4.7 146 4.8     4.5
## 4        2.6       4.0 141 4.2     4.6
## 5        1.7       3.9 141 4.4     4.1
## 6        1.9       3.0 138 4.1     4.3
```

– 我們先進行一個前處理，刪掉日期不符的變項

```
dat$Date = as.Date(dat[,"Date"])
dat = dat[!dat$Date %in% NA,]
levels.Patient = levels(as.factor(dat$Patient))
```

# 進階驗證篩選(2)

– 首先，我們還是先創造一個新變項

```
dat$Wrong.Date_interval = NA
```

- 接著，我們先處理一個人。先叫出資料來，但其實我們並不一定要先把這個人的資料存出來，可以透過索引函數直接作業，這樣也可以直接把Wrong.Date_interval填完

– 我們選擇第5個人

```
i = 5
dat[dat$Patient==levels.Patient[i],c("Patient", "Date", "Wrong.Date_interval")]
##    Patient       Date Wrong.Date_interval
## 41     566 2008-03-21                  NA
## 42     566 2008-05-17                  NA
## 43     566 2008-06-10                  NA
## 44     566 2008-06-16                  NA
## 46     566 2008-07-12                  NA
```

- 在現在的規則中，第一筆絕對是正確的，故直接先將第一筆填入FALSE，剩下的再想辦法

```
i = 5
dat[dat$Patient==levels.Patient[i],"Wrong.Date_interval"][1] = FALSE
dat[dat$Patient==levels.Patient[i],c("Patient", "Date", "Wrong.Date_interval")]
##    Patient       Date Wrong.Date_interval
## 41     566 2008-03-21               FALSE
## 42     566 2008-05-17                  NA
## 43     566 2008-06-10                  NA
## 44     566 2008-06-16                  NA
## 46     566 2008-07-12                  NA
```

# 進階驗證篩選(3)

- 透過迴圈，我們能夠從第二筆開始檢查他是否間格不夠。

– 值得注意的是，這位病患在『2008-03-21』、『2008-05-17』、『2008-06-10』這三天分別被申報，其間格分別是27與65，雖然『2008-05-17』必須被核刪，但考慮到刪除這天後，『2008-03-21』與『2008-06-10』就相距81天，這是一個可以接受的日期，所以我們必須想一下，該怎麼解決這件事。

- 我們可以在迴圈進行時，找尋『Wrong.Date_interval』為FALSE的最後一筆出來，之後並以他為標記做相減

– 記得避免遺漏值！

```
i = 5
dat[dat$Patient==levels.Patient[i],"Wrong.Date_interval"][1] = FALSE
n.date = length(dat[dat$Patient==levels.Patient[i],"Date"])

k = 2
false.dates = dat[dat$Patient==levels.Patient[i] & dat$Wrong.Date_interval == FALSE & !is.na(dat$Wrong.Date_interval),"Date"]
last.date = false.dates[length(false.dates)]
dif = dat[dat$Patient==levels.Patient[i],"Date"][k] - last.date
dat[dat$Patient==levels.Patient[i],"Wrong.Date_interval"][k] = dif < 60

dat[dat$Patient==levels.Patient[i],c("Patient", "Date", "Wrong.Date_interval")]
##    Patient       Date Wrong.Date_interval
## 41     566 2008-03-21               FALSE
## 42     566 2008-05-17                TRUE
## 43     566 2008-06-10                  NA
## 44     566 2008-06-16                  NA
## 46     566 2008-07-12                  NA
```

# 進階驗證篩選(4)

- 接著我們只要將i以及k打包成迴圈就完成了

– 需要注意的是，如果n.date>1才需要做後續檢查

```
levels.Patient = levels(as.factor(dat$Patient))
n.Patient = length(levels.Patient)
dat$Wrong.Date_interval = NA

pb = txtProgressBar(max = n.Patient, style=3)

for (i in 1:n.Patient) {
  dat[dat$Patient==levels.Patient[i],"Wrong.Date_interval"][1] = FALSE
  n.date = length(dat[dat$Patient==levels.Patient[i],"Date"])
  if (n.date>1) {
    for (k in 2:n.date) {
      false.dates = dat[dat$Patient==levels.Patient[i] & dat$Wrong.Date_interval == FALSE & !is.na(dat$Wrong.Date_interval),"Date"]
      last.date = false.dates[length(false.dates)]
      dif = dat[dat$Patient==levels.Patient[i],"Date"][k] - last.date
      dat[dat$Patient==levels.Patient[i],"Wrong.Date_interval"][k] = dif < 60
    }
  }
  setTxtProgressBar(pb, i)
}

close(pb)
```

# 快速讀寫檔案(1)

- 在這節課之前，我們使用的函數種類相當有限，但我們也在之前的範例中發現了不同程式碼執行同樣的事情在速度上有顯著的不同。

– 不同的主因其實牽涉到程式碼執行過程，但目前我們的知識很有限，做出來就不容易了更別說還要求速度快，因此比較可行的方式是去「抄」程式碼！

- 在讀取檔案的部分，我們這裡先介紹一個特別的套件：[data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)，它裡面有眾多協助我們加速處理大量資料的函數

# 快速讀寫檔案(2)

- 使用一般的R程式，可以在Console地方打上這個指令：

```
install.packages("data.table")
```

- 安裝完成後，未來我們要使用這個套件只要打上這串指令：

```
library(data.table)
```

# 快速讀寫檔案(3)

- 讓我們來體驗一下data.table套件內一個神奇的函數：「fread」，它可以以數倍的速度讀取一個csv檔案：

– 至於大Data在哪，我們可以使用第六節課用到的大檔案，請在[這裡](https://linchin.ndmctsgh.edu.tw/data/laboratory_2.csv)下載。

- 這是使用「read.csv」讀取的速度：

```
t0 = Sys.time()
dat1 = read.csv('laboratory_2.csv', header = TRUE, fileEncoding = 'CP950')
Sys.time() - t0
## Time difference of 1.707349 secs
```

- 這是使用「fread」讀取的速度：

```
t0 = Sys.time()
dat2 = fread('laboratory_2.csv', header = TRUE)
Sys.time() - t0
## Time difference of 0.07944632 secs
```

# 快速讀寫檔案(4)

- 比較討厭的地方在使用「fread」讀取進來的物件格式是「data.table」，這是一個 新的物件格式。

```
class(dat1)
## [1] "data.frame"
class(dat2)
## [1] "data.table" "data.frame"
```

- 解決這個問題的方式是在使用「fread」的時候多給一個參數：

```
t0 = Sys.time()
dat2 = fread('laboratory_2.csv', header = TRUE, data.table = FALSE)
Sys.time() - t0
## Time difference of 0.1181285 secs
class(dat2)
## [1] "data.frame"
```

# 快速讀寫檔案(5)

- 但現在兩者還不完全一樣，問題出在哪呢?

```
all.equal(dat1, dat2)
## [1] "Component \"COLLECTIONDATE\": 'current' is not a factor"
## [2] "Component \"TESTNAME\": 'current' is not a factor"      
## [3] "Component \"UNITS\": 'current' is not a factor"
```

- 原來是使用「read.csv」有另一個參數「stringsAsFactors」，預設是TRUE，但使用「fread」的時候預設卻是FALSE，所以我們再改變一下：

```
dat1 = read.csv('laboratory_2.csv', header = TRUE, stringsAsFactors = FALSE, fileEncoding = 'CP950')
```

- 除此之外，還有encoding的問題，但這個我們必須透過手動修正「laboratory_2.csv」編碼解決。

```
all.equal(dat1, dat2)
## [1] "Component \"COLLECTIONDATE\": 181483 string mismatches"
```

# 快速讀寫檔案(6)

- 除了讀取檔案之外，寫出檔案也可以使用「fwrite」函數進行加速：

– 這是使用「write.csv」寫出的速度：

```
t0 = Sys.time()
write.csv(dat1, 'laboratory_test.csv', row.names = FALSE, quote = TRUE)
Sys.time() - t0
## Time difference of 0.9308543 secs
```

– 這是使用「fwrite」寫出的速度：

```
t0 = Sys.time()
fwrite(dat2, 'laboratory_test.csv', row.names = FALSE, quote = TRUE)
Sys.time() - t0
## Time difference of 0.0409317 secs
```

# 快速讀寫檔案(7)

- 另外還有一種儲存、載入物件的方式，使用R內建的「save」與「load」函數甚至可以完全保留物件原有的所有屬性，並且能夠把任何物件存出，也具有較小的儲存空間：

– 這是儲存

```
t0 = Sys.time()
save(dat1, file = 'laboratory_test.RData')
Sys.time() - t0
## Time difference of 0.6009369 secs
```

– 這是載入

```
t0 = Sys.time()
load('laboratory_test.RData')
Sys.time() - t0
## Time difference of 0.204529 secs
```

# 增加程式可讀性(1)

- 在R裡面我們經常會使用到組合函數，像是假使我們想要知道生化值的數量共有幾項，我們可以透過下面這種方法得知：

```
length(levels(factor(dat1$TESTNAME)))
## [1] 25
```

- 而這樣程式寫起來會很複雜，比較好的方式應該是這樣：

```
factorized_TESTNAME = factor(dat1$TESTNAME)
lvl_TESTNAME = levels(factorized_TESTNAME)
length(lvl_TESTNAME)
## [1] 25
```

- 但這樣在R裡面會額外儲存很多垃圾物件，並且會拖慢運算速度，因此如何在程式可讀性與執行速度上做平衡呢?

# 增加程式可讀性(2)

- 這裡我們介紹另一個套件「magrittr」，它擁有一個特殊的運算符號「%>%」，功能是把從左到右依序執行任務

– 後面函數的「.」代表上一步的結果

```
library(magrittr)

n.TESTNAME = dat1$TESTNAME %>% factor %>% levels %>% length
n.TESTNAME
## [1] 25
n.TESTNAME = dat1$TESTNAME %>% factor() %>% levels() %>% length()
n.TESTNAME
## [1] 25
n.TESTNAME = dat1$TESTNAME %>% factor(.) %>% levels(.) %>% length(.)
n.TESTNAME
## [1] 25
```

- 為什麼需要「.」這種方式呢，這是因為假使你的函數需要指令參數，那可以透過這種方式來寫出：

```
f = function(x, a, b) {a*x^2 + b}
1:5 %>% f(., 2, 5)
## [1]  7 13 23 37 55
1:5 %>% f(2, ., 5)
## [1]  9 13 17 21 25
1:5 %>% f(2, 5, .)
## [1] 21 22 23 24 25
```

# 增加程式可讀性(3)

- 我們再多介紹幾個特殊的運算符號(這兩個比較不常用)：

– 「%<>%」：不要顯示結果，而是改變物件內容

```
a = 1
a %<>% add(1)
a
## [1] 2
```

– 「%$%」：指定物件內的索引格式

```
n.TESTNAME = dat1 %$% TESTNAME %>% factor %>% levels %>% length
n.TESTNAME
## [1] 25
```

# 增加程式可讀性(4)

- 學習特殊運算符號的目標除了是增加自己程式的可讀性之外，更重要的是會增加及執行速度！
- 讓我們看看結合了眾多改變後，再回頭看看第六課的練習一這個任務要花多久：

```
t0 = Sys.time()

dat1$COLLECTIONDATE = dat1[,3] %>% as.Date

levels.TESTNAME = dat1[,4] %>% factor %>% levels
n.TESTNAME = levels.TESTNAME %>% length
levels.PATNUMBER = dat1[,1] %>% factor %>% levels
n.PATNUMBER = levels.PATNUMBER %>% length

dat_list = list()

for (i in 1:n.PATNUMBER) {
  
  subdat = dat1[dat1[,1]==levels.PATNUMBER[i],]
  levels.COLLECTIONDATE = subdat[,3] %>% factor %>% levels
  n.COLLECTIONDATE = levels.COLLECTIONDATE %>% length

  submatrix = matrix(NA, nrow = n.COLLECTIONDATE, ncol = n.TESTNAME + 2)
  colnames(submatrix) = c("PATNUMBER", "COLLECTIONDATE", levels.TESTNAME)

  submatrix[,1] = levels.PATNUMBER[i]
  submatrix[,2] = levels.COLLECTIONDATE

  for (j in 1:n.COLLECTIONDATE) {
    subsubdat = subdat[subdat[,3]==levels.COLLECTIONDATE[j],]
    for (k in 1:nrow(subsubdat)) {
      NAME = subsubdat[k,4]
      position = which(NAME == levels.TESTNAME) + 2
      submatrix[j, position] = subsubdat[k,5]
    }
  }
  
  dat_list[[i]] = submatrix
}

final.data = do.call("rbind", dat_list)

Sys.time() - t0
## Time difference of 1.657264 mins
head(final.data)
##      PATNUMBER COLLECTIONDATE Albumin Albumin body fluid AST BUN BUN Fluid
## [1,] "26"      "2011-05-12"   NA      NA                 NA  NA  NA       
## [2,] "26"      "2011-05-30"   NA      NA                 NA  NA  NA       
## [3,] "26"      "2011-05-31"   NA      NA                 NA  NA  NA       
## [4,] "26"      "2011-06-01"   NA      NA                 NA  NA  NA       
## [5,] "26"      "2011-06-02"   NA      NA                 NA  NA  NA       
## [6,] "26"      "2011-06-06"   NA      NA                 NA  NA  NA       
##      Cholesterol Fluid Creatinine Creatinine Fluid GLU(AC) HDL-Cholesterol
## [1,] NA                "1.8"      NA               NA      NA             
## [2,] NA                "3"        NA               NA      NA             
## [3,] NA                "2.9"      NA               NA      NA             
## [4,] NA                "2.9"      NA               NA      NA             
## [5,] NA                "2.4"      NA               NA      NA             
## [6,] NA                "1.9"      NA               NA      NA             
##      IP    K  LDL-Cholesterol Na    NA Fluid Total Calcium Total Cholesterol
## [1,] NA    NA NA              "140" NA       NA            NA               
## [2,] NA    NA NA              "139" NA       NA            NA               
## [3,] "4.6" NA NA              "145" NA       "7.8"         "134"            
## [4,] NA    NA NA              "144" NA       "6.1"         NA               
## [5,] NA    NA NA              "138" NA       "7.1"         NA               
## [6,] NA    NA NA              "134" NA       "8"           NA               
##      Triglyceride Triglycerol Fluid Uric Acid urine Calcium urine Phosphorus
## [1,] NA           NA                NA        NA            NA              
## [2,] NA           NA                NA        NA            NA              
## [3,] "131"        NA                NA        "5.6"         "41.4"          
## [4,] NA           NA                NA        NA            NA              
## [5,] NA           NA                NA        NA            NA              
## [6,] NA           NA                NA        NA            NA              
##      urine Potassium urine Sodium urine Uric Acid
## [1,] NA              NA           NA             
## [2,] NA              NA           NA             
## [3,] "29"            "61"         NA             
## [4,] NA              NA           NA             
## [5,] NA              NA           NA             
## [6,] NA              NA           NA
```

- 居然1分多鐘就做完了，配上讀取/寫出檔案的時間加起來也不超過1分半，看來大檔案的處理也並不怎麼可怕！

```
final.data = as.data.frame(final.data, stringsAsFactors = FALSE)

fwrite(final.data, 'final_data.csv', row.names = FALSE, quote = TRUE)
```

# Ch 09 簡易繪圖功能

# 基礎繪圖函數簡介-1(1)

- 同樣的資訊，使用圖像相呈現較於表格/文字，通常能讓閱讀者更快的獲得資訊。
- 在R裡面，我們能夠畫出任何統計圖！

– 請至[這裡](https://linchin.ndmctsgh.edu.tw/data/Example_data.csv)下載本週的範例資料

```
dat = read.csv("Example_data.csv", header = TRUE)
head(dat)
##       eGFR Disease Survival.time Death Diabetes Cancer      SBP      DBP
## 1 34.65379       1     0.4771037     0        0      1 121.2353 121.3079
## 2 37.21183       1     3.0704424     0        1      1 122.2000 122.6283
## 3 32.60074       1     0.2607117     1        0      0 118.9136 121.7621
## 4 29.68481       1            NA    NA        0      0 118.2212 112.7043
## 5 28.35726       0     0.1681673     1        0      0 116.7469 115.7705
## 6 33.95012       1     1.2238556     0        0      0 119.9936 116.3872
##   Education Income
## 1         2      0
## 2         2      0
## 3         0      0
## 4         1      0
## 5         0      0
## 6         1      0
```

# 基礎繪圖函數簡介-1(2)

- 我們先從幾個簡單的統計圖開始

1. 直方圖：需要使用函數「hist()」

```
hist(dat[,"eGFR"])
```

1. 盒鬚圖：需要使用函數「boxplot()」

```
boxplot(dat[,"eGFR"])
```

1. 圓餅圖：需要使用函數「pie()」以及函數「table()」

```
pie(table(dat[,"Education"]))
```

1. 長條圖：需要使用函數「barplot()」以及函數「table()」

```
barplot(table(dat[,"Education"]))
```

# 基礎繪圖函數簡介-1(3)

- 這些圖都能透過增加不同的參數增加變化，我們可以透過函數「help()」查詢它們內部的參數。舉例來說，我們可以用下列方式改變圖的顏色

– 在R裡面的顏色可以在[Colors in R](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)裡查看

– 另外，這裡教一個新函數「par()」，他可以指定繪圖環境。其中最常見的應用為把4張圖放在同一張畫布內：

```
par(mfrow = c(2, 2))
hist(dat[,"eGFR"], col = "red")
boxplot(dat[,"eGFR"], col = "blue")
pie(table(dat[,"Education"]), col = c("blue", "red", "green"))
barplot(table(dat[,"Education"]), col = c("gray90", "gray50", "gray10"))
```

- 範例程式碼：

```
boxplot(count ~ spray, data = InsectSprays, col = "lightgray")
```

- 我們可以用我們的資料套進來：

```
boxplot(dat[,"eGFR"] ~ dat[,"Disease"], col = c("blue", "red"), ylab = "eGFR", xlab = "Disease", main = "eGFR value by Disease status", lwd = 1.5)
```

# 基礎繪圖函數簡介-2(1)

- 接著我們介紹一個強大的函數「plot()」，他支援了多種不同的圖形，其中最主要的是散布圖：

```
plot(dat[,"SBP"], dat[,"DBP"], ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP")
```

- 其實，我們可以修改點的造型，例如：

```
plot(dat[,"SBP"], dat[,"DBP"], ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP", pch = 19)
```

# 基礎繪圖函數簡介-2(2)

- 你可以為你的圖形加點東西，首先我們先介紹函數「lines()」。

– 函數「lines()」的效果是按照順序把幾個點連起來，舉例來說…

– 註：函數「plot.new()」及函數「plot.window()」是拿來開一張新畫布用的！

```
x = c(1, 4, 7)
y = c(2, 9, 6)
plot.new()
plot.window(xlim = c(0, 10), ylim = c(0, 10))
lines(x, y)
```

- 當然，如果點夠密，你其實可以畫出圓！

```
z = 0:1000/100
x = sin(z) #三角函數sin
y = cos(z) #三角函數cos
plot.new()
plot.window(xlim = c(-1, 1), ylim = c(-1, 1))
lines(x, y)
```

# 基礎繪圖函數簡介-2(3)

- 學會函數「lines()」以後，我們能夠幫散布圖上加預測線了…

– 預測線的方程式，需要函數「lm()」幫忙建立，你看得懂下面的程式碼嗎？

```
# 建立MODEL以及預測線的座標
X = dat[,"SBP"]
Y = dat[,"DBP"]
model = lm(Y~X)
COEF = model$coefficients
x = c(0, 200)
y = COEF[1] + COEF[2] * x

plot(dat[,"SBP"], dat[,"DBP"], ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP", pch = 19)
lines(x, y, col = "red", lwd = 2)
```

# 基礎繪圖函數簡介-2(4)

- 其實，你還可以為你的圖形加點料…

1. 函數「text()」可以為你的圖片上加文字描述

```
x = c(1, 0, -1, 0)
y = c(0, 1, 0, -1)
t = c("A", "B", "C", "D")
plot.new()
plot.window(xlim = c(-1, 1), ylim = c(-1, 1))
text(x, y, t)
```

1. 函數「points()」可以為你的圖片上加點

```
x = c(1, 0, -1, 0)
y = c(0, 1, 0, -1)
plot.new()
plot.window(xlim = c(-1, 1), ylim = c(-1, 1))
points(x, y, pch = 1:4)
```

1. 函數「legend()」可以為你的圖片加上註釋

```
plot.new()
plot.window(xlim = c(-1, 1), ylim = c(-1, 1))
legend("topleft", c("Female", "Male"), col = c("red", "blue"), pch = c(15, 19), bg = "gray90")
legend(0, 0, c("estimates", "95% CI"), lty = c(1, 2), lwd = 2, col = "black")
```

1. 函數「polygon()」可以畫多邊形

```
x = c(1, 0, -1, 0)
y = c(0, 1, 0, -1)
plot.new()
plot.window(xlim = c(-1, 1), ylim = c(-1, 1))
polygon(x, y, col = "green")
```

# 色彩透明度與函數(1)

- 還記得剛剛的SBP對DBP的散布圖嗎?是不是感覺到有很多點重疊在一起。

– 資料量多的時候經常會遇到這樣的問題，這時候我們可能需要告訴使用者不同區域點的密度。

```
plot(dat[,"SBP"], dat[,"DBP"], ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP", cex = 2)
```

```
plot(dat[,"SBP"], dat[,"DBP"], ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP", pch = 19, cex = 2)
```

# 色彩透明度與函數(2)

- 在R裡面，我們使用的是6或8位元的16進位色碼，其規格為：#[紅色][綠色][藍色][透明度]

– 舉例來說，不透明的紅色的色碼為『#FF0000』或『#FF0000FF』

– 透明度50%的紅色色碼為『#FF000080』

– 透明度50%的黑色色碼為『#00000080』

```
x = c(1, 0, -1, 0)
y = c(0, 1, 0, -1)
plot.new()
plot.window(xlim = c(-1, 1), ylim = c(-1, 1))
points(x, y, pch = 19, cex = 2, col = c("#FF0000", "#FF0000FF", "#FF000080", "#00000080"))
```

- 如果你懶得自己想色碼，函數「rgb()」可以協助你調色

```
rgb(1, 0, 0, 0.5)
## [1] "#FF000080"
rgb(0.7, 0.5, 0.3, 0.7)
## [1] "#B3804DB3"
```

- 有了半透明的顏色後，剛剛的散布圖終於可以看出密度了

```
plot(dat[,"SBP"], dat[,"DBP"], ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP", pch = 19, cex = 2, col = "#00000030")
```

# 色彩透明度與函數(3)

- 事實上，函數「smoothScatter()」可以畫出與剛剛類似的散布圖：

```
smoothScatter(dat[,"SBP"], dat[,"DBP"], nrpoints = 0, ylab = "DBP", xlab = "SBP", main = "Scatter plot of SBP and DBP")
```