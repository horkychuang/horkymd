# Ch 01 R語言基本介紹及環境安裝

# 為什麼是R語言?

- R語言主要用於統計分析、繪圖、資料探勘等。

1. R有非常先進的數據視覺化系統
2. R有很多進階數據分析工具
3. R是完整的資料科學解決方案

- 他是資料探勘從業人員中最普及的工具。

– 與其他統計軟體相比，R語言更接近程式語言，因此在熟悉以後更能建立自己的常規工作pipeline，加快自己的工作效率。

– 與其他程式語言相比，R語言更專注在統計分析功能的開發上，因此相關的功能較完善，比較容易找到合適的函數進行運算。

– R語言是生物資訊、統計分析、資料科學領域上的強勢語言，這些都是醫學院的學生未來比較有可能涉獵的領域。

– 截止至2021年4月，R 在[TIOBE Index](https://www.tiobe.com/tiobe-index/)排名第16位。

# 安裝R語言(1)

- 要開始使用R語言，你必須先到[CRAN](http://www.r-project.org/)下載檔案，安裝後才可以使用

– 以Download R for Windows為例。

– 選Download R 4.0.4 for Windows，如要下載先前版本選Previous releases



# 與電腦交談(1)

- R語言的編寫是屬於一種『交談式編程』的設計，我們現在可以把R語言作為與電腦溝通的語言，而每當我們對其下達一個指令，電腦將會回應我們的問題。

– 因此，使用R的第一步，請先將他當作一個高級的計算機。

– 請試著在左邊的Console視窗中，輸入下列程式碼，並體會他的計算功能

```
# 四則運算
123 + 489
145 * 12

# 括弧優先規則
(1 + 2) * 3

# 指數運算
12^4
```

# 與電腦交談(2)

- 接著，我們介紹R語言中第一個重要的元素：函數。

– 『函數』的使用方式是打下特定的字句，並且在『小括號』內輸入參數作為「input」，接著電腦將會根據你的指令進行回答。

- 在這裡我們先介紹3個常用的計算函數，分別是：

1. 函數「exp()」：負責進行自然指數運算
2. 函數「sqrt()」：負責進行平方根運算
3. 函數「log()」：負責(自然)對數運算

```
exp(2)
sqrt(10)
log(3)
```

– 有趣的是，『函數』中的『input』不見得只能有1個，如函數「log()」可以額外輸入對數的底數，並以『,』進行分隔：

```
log(3, base = 3)
log(4, base = 2)
```

– 需要注意的是，如果我們不告訴電腦哪個是底數，哪個是運算目標，哪個是底數，那他將會依序認為你輸入的第一個數為需要被運算的數，而第二個數為底數：

```
log(9, 3)
log(8, 2)
```

# 與電腦交談(3)

- 剛剛那些運算結果，我們沒有辦法將他們存下來，現在我們要將這些計算結果儲存成一個『物件』

– 註：物件的屬性有很多種，我們第二節才會對他進行詳細的介紹

– 注意，等號的右邊為「input」，等號的左邊為「output」

- 現在請輸入下列這串程式碼，這代表著我們要將「2 * 3」的結果儲存在「x」這個物件內

```
x = 2 * 2 * 3
```

- 我們可以利用函數「print()」查看物件內容

```
print(x)
```

– 如果你只是需要查看物件內容，事實上直接輸入物件名稱也可以達到相同效果

```
x
```

– 物件強大的地方在於，我們可以將其做為暫存的工具，並且可以直接對「x」物件進行運算

```
x/4
```

# 與電腦交談(4)

- 現在我們已經了解到物件本身能進行簡單的加減乘除，因此現在我們想要同時對1到5一起做三次方的運算，這時候我們可以這樣做

– 函數「c()」中間以逗點為界，此函數可以將不同「數字」合併在同一個物件內

```
x = c(1, 2, 3, 4, 5)
x
x^3
```

- 兩個物件也能彼此互相進行加減乘除

```
x = c(1, 2, 3, 4, 5)
y = c(6, 7, 9, 8, 10)
y - x
x * y
```

# 物件索引(1)

- 接著我們將學習利用物件索引叫出物件內的特定內容
- 在R裡面，「中括號」是索引函數，在物件的後面使用「中括號」，將可以叫出指定位置的內容

```
y = c(6, 7, 9, 8, 10)
y[1]
y[c(3, 5)]
y[6]
```

- 注意，我們也可以使用「負數」索引，他的效果是顯示該數字以外的結果：

```
y = c(6, 7, 9, 8, 10)
y[-1]
y[-c(3, 5)]
```

# 物件索引(2)

- 我們可以利用索引函數指定某個位置作為「Output」，並將某個運算的結果寫入該位置

```
y[7] = 3 * 5
y
```

- 如果該位置原先已經有內容了，將會被強行覆蓋掉

```
y[3] = -1
y
```

- 也可以這樣操作

```
y[3] = y[1] + y[2]
y[6] = y[4] * y[5]
y
```

# 熟悉R裡面的基本物件(1)

- 我們正式介紹一下物件，在R裡面物件有相當多屬性，而剛剛那兩個物件屬於同個種類叫做「向量(vector)」，在R裡面大致上將物件分為幾個層次，主要共分3個層次：

1. 變數(Variable)層：邏輯(logical)向量、整數(integer)向量、因子(factor)向量、數字(numeric)向量、文字(character)向量
2. 陣列(Array)層：矩陣(matrix)、資料表(data.frame)
3. 列表(List)層：列表(list)、S3物件(S3 class)、S4物件(S4 class)

# 熟悉R裡面的基本物件(2)

- 在這裡我們先不要被一大堆名詞定義給嚇到，我們先從簡單的變數(Variable)層物件開始認識，其他的部分到我們開始使用後再學習。
- 變數層中有幾個函數相當重要：

– 函數「as.XXX()」：可以強迫某個向量內所有的內容全部轉換為該種類

– 函數「class()」：可以查詢該物件的屬性

```
a = c(TRUE, FALSE, TRUE, FALSE)
class(a)

b = c(1, 2, 3, 4, 5)
class(b)
b1 = as.integer(b)
class(b1)

c = c(0.7, -0.9, 1.2, -2.1, 3.7)
c1 = as.integer(c)
c1

d = c("A", "B", "C", "C", "B")
class(d)
d1 = as.factor(d)
d1

e = c(c, d)
e
class(e)

e1 = c(c1, d1)
e1
class(e1)
```

# 熟悉R裡面的基本物件(3)

- 變數(Variable)層物件中有幾個重要的函數來描述它的基本資料，這裡我們要學習一下

1. 函數「length()」可以查詢該向量的長度
2. 函數「levels()」可以查詢因子向量的類別種類

```
d = c("A", "B", "C", "C", "B")
class(d)
d1 = as.factor(d)
d1

n = length(d1)
n

categories = levels(d1)
categories
```

- 在這邊我們介紹第一個函數組合所產生的效果，對於一個因子物件，如果我們把函數「length()」與函數「levels()」做結合，看看會發生什麼事情

```
categories = levels(d1)
n.categories = length(categories)
n.categories

# 用下列這串意思一樣
n.categories = length(levels(d1))
n.categories
```

# Ch 02 R條件判斷與迴圈

# 條件判斷式(1)

- 在R裡面，要判斷數字大小，可以使用下列幾個判斷語句：「>」、「>=」、「==」、「!=」、「<」、「<=」，而R會回傳邏輯(logical)向量

```
1 < 2
2 == 1 + 1
"Z" > "B"
```

- 當然，一整個向量可以一起使用判斷式，如下

```
x = c(1, 2, 3, 4, 5)
x <= 4
x > 2
```

# 條件判斷式(2)

- 我們可以利用「&」、「|」兩個符號將條件「交集」與「聯集」，以取得更複雜的組合

```
x = c(1, 2, 3, 4, 5)
x <= 4 & x > 2
x > 4 | x <= 2
```

# 條件判斷式(3)

- 我們可以利用函數「if」，讓滿足條件時，請R執行某些指令(要執行的指令要包含在大括號內)

```
if ("Z" > "B") {x = 2} else {x = 5}
if ("利" > "弊") {y = 3} else {y = 4}
x * y
```

- 我們已經知道一整個向量可以一起使用同個條件判斷式了，那可不可以一起包在if的括號內呢?

– 答案是不行的，因為函數「if」的括弧內僅能包含「一個」邏輯值(請同學試試)

- 那如果我們想要把物件「x」中大於2及小於等於4的部分改變成-1，我們可以利用索引函數做到這件事（索引值可以放入「邏輯向量」！）

```
x = c(1, 2, 3, 4, 5)
x[x <= 4 & x > 2] = -1
x
```

- 再介紹一個特殊的函數「which()」

– 函數「which()」會將邏輯向量中為TRUE的位置回傳給我們

```
a = c(TRUE, FALSE, FALSE, TRUE, FALSE)
which(a)
```

# 迴圈(1)

- 費波納奇數列：起始數列為1、1，之後每個數為前兩個數之和

```
x = c(1, 1)
x[3] = x[2] + x[1]
x[4] = x[3] + x[2]
x[5] = x[4] + x[3]
x[6] = x[5] + x[4]
x
## [1] 1 1 2 3 5 8
```

# 迴圈(2)

- 在剛剛的任務中我們注意到了一件事情，也就是每一行指令中索引函數都會一起增加1，所以我們現在使用另一個物件i來表示每一行指令中共同的部分

```
x = c(1, 1)

i = 3
x[i] = x[i-1] + x[i-2]

i = 4
x[i] = x[i-1] + x[i-2]

i = 5
x[i] = x[i-1] + x[i-2]

i = 6
x[i] = x[i-1] + x[i-2]

x
## [1] 1 1 2 3 5 8
```

- 透過物件i，我們將能整合所有的運算過程，只要讓i能夠依序提升即可，這是運用迴圈前的基本邏輯！

# 迴圈(3)

- 我們可以利用迴圈函數「for」，來創造費波納奇數列

– 在這裡我們需要兩個物件：物件「x」為儲存費波納奇數列的物件，而物件「indexes」代表著隨迴圈變化的物件

– 注意，在這裡我們第一次使用運算子「:」，而「3:20」表示從3到20的所有整數

```
x = c(1, 1)
indexes = 3:20
indexes
##  [1]  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
for (i in indexes) {
  x[i] = x[i-1] + x[i-2]
}

x
```

# 迴圈(4)

- 剛剛那個迴圈函數的運作原理，是重複執行18次類似的動作，其中i變數在第一次的時候是物件「indexes」中的第一個內容「3」，因此在第一個迴圈中R其實是做了這樣的事情

```
i = 3 #物件「indexes」中的第一個數字
x[i] = x[i-1] + x[i-2]
```

- 而第二迴圈則是

```
i = 4 #物件「indexes」中的第二個數字
x[i] = x[i-1] + x[i-2]
```

- 依此類推，到最後一個迴圈時則是…

```
i = 20 #物件「indexes」中的最後一個數字
x[i] = x[i-1] + x[i-2]
```

- 根據上述流程，R重覆將物件「x」擴充了18次，加上最初的2個起始値，物件「x」現在為一個長度為20的數字(numeric)向量

# 迴圈(5)

- 值得一提的是，我們可以將直接在「in」後面直接使用序列數字進行表示，並且可以獲得完全相同的結果

```
x = c(1, 1)

for (i in 3:20) {
  x[i] = x[i-1] + x[i-2]
}

x
```

# 迴圈(6)

- 迴圈中的變數不見得必須是數字，可以是任何屬性（如文字），下面是一個類似合併列印功能的函數

– 函數「cat」的功能是將文字前後連接起來並輸出在Console視窗中

```
students = c("小華", "小明", "小王")
scores = c(100, 80, 70)

for (i in 1:3) {
  cat(students[i], "的考試成績為", scores[i], "分\n")
}
## 小華 的考試成績為 100 分
## 小明 的考試成績為 80 分
## 小王 的考試成績為 70 分
```

# NDMC數列

- 費波納奇數列是起始數列為1、1，之後每個數為前兩個數之和

– 而我們現在創造一個NDMC數列，其定義是起始數列為1、1，之後第三個數字（奇數）為前兩個相加，第四個數字（偶數）為前兩個數字相乘，第五個數字（奇數）為前兩個相加，依此類推。

- 迴圈的形式：

```
y = c(1, 1)

for (i in 1:8) {
  if (i == '奇數') {
    y[i+2] = y[i] + y[i+1]
  } else {
    y[i+2] = y[i] * y[i+1]
  }
}

y
```

- 解法是最有趣的，還記得-1的n次方嗎？

```
y = c(1, 1)

for (i in 1:8) {
  if ((-1)^i == -1) {
    y[i+2] = y[i] + y[i+1]
  } else {
    y[i+2] = y[i] * y[i+1]
  }
}

y
```

二循環的迴圈

```
y = c(1, 1)

for (i in 1:4) {
  y[2*i+1] = y[2*i-1] + y[2*i]
  y[2*i+2] = y[2*i] * y[2*i+1]
}

y
```

# 多層次迴圈(1)

- 迴圈的美妙之處在於大量且快速的運算，而我們即將透過迴圈功能進行更複雜的組合任務

– 現在讓我們想辦法列出2:6內所有的「質數」

– 何謂質數?質數的定義為找不到比自己更小的可整除除數，如5以下的數字為2、3、4，而5無法被這些數字整除

- 先產生一個物件x為2至6的所有數字

– 再使用函數「rep()」產生一個等長的物件answer.x表示物件x中相對應的元素是否為質數，而預設通通為TRUE

```
x = 2:6
answer.x = rep(TRUE, 5) #你也可以使用length(x)來替代5
```

- 一步一步來，先從3開始找起(3是x物件中的第2個數字)…

```
#對3進行檢測(x物件中的第2個數字)
if (x[2] %% x[1] == 0) {answer.x[2] = FALSE}

#對4進行檢測(x物件中的第3個數字)
if (x[3] %% x[1] == 0) {answer.x[3] = FALSE}
if (x[3] %% x[2] == 0) {answer.x[3] = FALSE}
  
#對5進行檢測(x物件中的第4個數字)
if (x[4] %% x[1] == 0) {answer.x[4] = FALSE}
if (x[4] %% x[2] == 0) {answer.x[4] = FALSE}
if (x[4] %% x[3] == 0) {answer.x[4] = FALSE}
  
#對6進行檢測(x物件中的第5個數字)
if (x[5] %% x[1] == 0) {answer.x[5] = FALSE}
if (x[5] %% x[2] == 0) {answer.x[5] = FALSE}
if (x[5] %% x[3] == 0) {answer.x[5] = FALSE}
if (x[5] %% x[4] == 0) {answer.x[5] = FALSE}
```

- 這樣我們使用answer.x做為x的索引函數，即可取得x內的質數：

```
x[answer.x]
## [1] 2 3 5
```

# 多層次迴圈(3)

- 聰明的你發現了一些規律，讓我們再次使用物件i來取代其中具有規律的部分…

```
#重新產生x與answer.x
x = 2:6
answer.x = rep(TRUE, 5)

#對3進行檢測(x物件中的第2個數字)
i = 2
if (x[i] %% x[1] == 0) {answer.x[i] = FALSE}

#對4進行檢測(x物件中的第3個數字)
i = 3
if (x[i] %% x[1] == 0) {answer.x[i] = FALSE}
if (x[i] %% x[2] == 0) {answer.x[i] = FALSE}
  
#對5進行檢測(x物件中的第4個數字)
i = 4
if (x[i] %% x[1] == 0) {answer.x[i] = FALSE}
if (x[i] %% x[2] == 0) {answer.x[i] = FALSE}
if (x[i] %% x[3] == 0) {answer.x[i] = FALSE}
  
#對6進行檢測(x物件中的第5個數字)
i = 5
if (x[i] %% x[1] == 0) {answer.x[i] = FALSE}
if (x[i] %% x[2] == 0) {answer.x[i] = FALSE}
if (x[i] %% x[3] == 0) {answer.x[i] = FALSE}
if (x[i] %% x[4] == 0) {answer.x[i] = FALSE}

#顯示所有質數
x[answer.x]
## [1] 2 3 5
```

# 多層次迴圈(4)

- 這時一個有趣的想法就是，能不能產生另外一個物件j來取代i仍然無法解決的跳動的部分…

```
#重新產生x與answer.x
x = 2:6
answer.x = rep(TRUE, 5)

#對3進行檢測(x物件中的第2個數字)
i = 2
j = 1
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}

#對4進行檢測(x物件中的第3個數字)
i = 3
j = 1
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 2
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
  
#對5進行檢測(x物件中的第4個數字)
i = 4
j = 1
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 2
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 3
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
  
#對6進行檢測(x物件中的第5個數字)
i = 5
j = 1
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 2
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 3
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 4
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}

#顯示所有質數
x[answer.x]
## [1] 2 3 5
```

# 多層次迴圈(5)

- 讓我們先關注於6的部分

```
#對6進行檢測(x物件中的第5個數字)
i = 5
j = 1
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 2
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 3
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
j = 4
if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
```

- 對於6的部分，似乎可以將這4行指令整合成一個以物件j為核心的迴圈…

```
#對6進行檢測(x物件中的第5個數字)
i = 5
for (j in 1:4) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}
```

# 多層次迴圈(6)

- 這個解法似乎可以擴展到所有的部分，差別只在於j的範圍不一致

```
#重新產生x與answer.x
x = 2:6
answer.x = rep(TRUE, 5)

#對3進行檢測(x物件中的第2個數字)
i = 2
for (j in 1:1) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}

#對4進行檢測(x物件中的第3個數字)
i = 3
for (j in 1:2) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}
  
#對5進行檢測(x物件中的第4個數字)
i = 4
for (j in 1:3) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}
  
#對6進行檢測(x物件中的第5個數字)
i = 5
for (j in 1:4) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}

#顯示所有質數
x[answer.x]
## [1] 2 3 5
```

# 多層次迴圈(7)

- 我們發現一件事情，那就是現在唯一會跳動的部分與物件i有關，他的最大值永遠是i-1，所以我們又能把程式整理成這樣…

```
#重新產生x與answer.x
x = 2:6
answer.x = rep(TRUE, 5)

#對3進行檢測(x物件中的第2個數字)
i = 2
for (j in 1:(i-1)) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}

#對4進行檢測(x物件中的第3個數字)
i = 3
for (j in 1:(i-1)) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}
  
#對5進行檢測(x物件中的第4個數字)
i = 4
for (j in 1:(i-1)) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}
  
#對6進行檢測(x物件中的第5個數字)
i = 5
for (j in 1:(i-1)) {
  if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
}

#顯示所有質數
x[answer.x]
```

- 迴圈的基本概念就是重複執行N次同樣的程式碼，而這段程式碼也可以中間有個迴圈，因此合併剛剛的例子可以用下面的方法：

```
#重新產生x與answer.x
x = 2:6
answer.x = rep(TRUE, 5)

#i與j的組合迴圈
for (i in 2:5) {
  for (j in 1:(i-1)) {
    if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
  }
}

#顯示所有質數
x[answer.x]
```

- 透過雙層迴圈，這下我們如果要從2檢查到100，那就是輕而易舉的事情了…

```
#重新產生x與answer.x
x = 2:100
answer.x = rep(TRUE, 99)

#i與j的組合迴圈
for (i in 2:99) {
  for (j in 1:(i-1)) {
    if (x[i] %% x[j] == 0) {answer.x[i] = FALSE}
  }
}

#顯示所有質數
x[answer.x]
```

# Ch 03 檔案讀取/寫出與基本操作

# 陣列(Array)層物件基本介紹(1)

- 在今天課程開始之前，我們要先介紹一下R裡面的陣列(Array)層物件(第一層物件介紹在Lesson 1中，各位可以複習一下)

– 陣列(Array)層分為矩陣(matrix)及資料表(data.frame)：

1. 矩陣(matrix)要求裡面的每個元素都為單一種類，因此與變數(Variable)層的向量類似，分為邏輯(logical)矩陣、整數(integer)矩陣、數字(numeric)矩陣、文字(character)矩陣[注意：因子(factor)向量被轉為矩陣時會變為文字矩陣]
2. 資料表(data.frame)可以允許每欄有不同的屬性，一個資料表內可以同時擁有不同屬性的變項。

- 我們首先介紹矩陣(matrix)物件

```
# 數値矩陣物件(注意將數字填入矩陣時的順序)
x1 = 1:20
M1 = matrix(x1, nrow = 4, ncol = 5)
M1
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
# 因子矩陣物件
x2 = c(0, 1, 2, 0, 2, 1, 1, 2, 0)
x2 = as.factor(x2)

M2 = matrix(x2, nrow = 3, ncol = 3)
M2
```

# 陣列(Array)層物件基本介紹(2)

- 矩陣的運算與一般運算有許多相異之處，我們在這裡介紹一下矩陣相關的運算函數

1. 函數「t()」可以求得轉置矩陣
2. 函數「solve()」可以求得反矩陣
3. 矩陣的乘法需要利用函數「%*%」來完成

```
x = 1:4
X = matrix(x, nrow = 2, ncol = 2)

X
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
t(X)
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
solve(X)
##      [,1] [,2]
## [1,]   -2  1.5
## [2,]    1 -0.5
y = 2:5
Y = matrix(y, nrow = 2, ncol = 2)
Y
##      [,1] [,2]
## [1,]    2    4
## [2,]    3    5
#注意下列兩者的差異
X%*%Y
##      [,1] [,2]
## [1,]   11   19
## [2,]   16   28
X*Y
##      [,1] [,2]
## [1,]    2   12
## [2,]    6   20
```

# 陣列(Array)層物件基本介紹(3)

- 繼續介紹陣列(Array)層物件中有幾個重要的函數來描述它的基本資料

1. 函數「length()」可以仍然可以用來查詢此陣列的總長度(長*寬)
2. 函數「nrow()」、「ncol()」可以查詢陣列的列欄數目

```
x1 = 1:20
M1 = matrix(x1, nrow = 4, ncol = 5)

length(M1)
## [1] 20
nrow(M1)
## [1] 4
ncol(M1)
## [1] 5
```

# 陣列(Array)層物件基本介紹(4)

- 繼續介紹陣列的索引函數，在R裡面所有的索引函數都由中括號形成，但由於陣列格式有兩個維度，所以需要指定row與column的位置，中間以逗點分隔，如下

```
x1 = 1:20
M1 = matrix(x1, nrow = 4, ncol = 5)
M1
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
# 猜猜這些指令是叫出哪個數字
M1[3,4]
M1[2,5]
M1[4,1]
```

- 値得注意的是，若將某部分留白，那視同叫出所有東西

```
# 也猜猜這些指令是叫出哪個東西
M1[3,]
M1[,1]
M1[,c(2, 5)]
```

# 陣列(Array)層物件基本介紹(5)

- 値得注意的是，陣列(Array)層物件能給定列/欄位名稱，分別使用函數「rownames()」及「colnames()」：

```
x1 = 1:20
M1 = matrix(x1, nrow = 4, ncol = 5)
rownames(M1) = c("a", "b", "c", "d")
M1
##   [,1] [,2] [,3] [,4] [,5]
## a    1    5    9   13   17
## b    2    6   10   14   18
## c    3    7   11   15   19
## d    4    8   12   16   20
colnames(M1) = c("A", "B", "C", "D", "E")
M1
##   A B  C  D  E
## a 1 5  9 13 17
## b 2 6 10 14 18
## c 3 7 11 15 19
## d 4 8 12 16 20
```

- 在給定名稱以後，索引函數也能透過給定的名稱來叫出該物件

```
M1["c","A"]
M1[,c("E", "C")]
```

- 另外，如果我們要修改已有的欄位名稱，我們可以透過函數「colnames()」與索引函數的結合做到

```
colnames(M1)[3] = "ZZZ"
M1
##   A B ZZZ  D  E
## a 1 5   9 13 17
## b 2 6  10 14 18
## c 3 7  11 15 19
## d 4 8  12 16 20
```

# 陣列(Array)層物件基本介紹(6)

- 接著我們介紹資料表(data.frame)物件，與矩陣物件不同的是，資料表允許每欄有不同的屬性，因此從矩陣轉資料表是不會改變太多結構的，但從資料表轉為矩陣就可能出現問題

```
x1 = 1:20
M1 = matrix(x1, nrow = 4, ncol = 5)
D1 = data.frame(M1)
D1
##   X1 X2 X3 X4 X5
## 1  1  5  9 13 17
## 2  2  6 10 14 18
## 3  3  7 11 15 19
## 4  4  8 12 16 20
rownames(M1) = c("a", "b", "c", "d")
colnames(M1) = c("A", "B", "C", "D", "E")

D2 = data.frame(M1)
D2
##   A B  C  D  E
## a 1 5  9 13 17
## b 2 6 10 14 18
## c 3 7 11 15 19
## d 4 8 12 16 20
colnames(D1) = c("A", "B", "C", "D", "E")
D1
##   A B  C  D  E
## 1 1 5  9 13 17
## 2 2 6 10 14 18
## 3 3 7 11 15 19
## 4 4 8 12 16 20
```

# 陣列(Array)層物件基本介紹(7)

- 資料表(data.frame)物件也能透過合併多個長度相同的向量(可以允許不同種類)來產生，並且在合併後不改變本來的屬性：

```
a = c(TRUE, FALSE, TRUE, FALSE, FALSE)
class(a)
## [1] "logical"
b = c(0.7, -0.9, 1.2, -2.1, 3.7)
class(b)
## [1] "numeric"
c = c("A", "B", "C", "C", "B")
c = as.factor(c)
class(c)
## [1] "factor"
DATA = data.frame(a, b, c)
DATA
##       a    b c
## 1  TRUE  0.7 A
## 2 FALSE -0.9 B
## 3  TRUE  1.2 C
## 4 FALSE -2.1 C
## 5 FALSE  3.7 B
class(DATA[,1])
## [1] "logical"
class(DATA[,2])
## [1] "numeric"
class(DATA[,3])
## [1] "factor"
```

# 陣列(Array)層物件基本介紹(8)

- 資料表(data.frame)除了能用矩陣的索引函數之外，從這個層級開始又多了一個索引函數「$」，它的使用方法如下：

```
DATA$b
## [1]  0.7 -0.9  1.2 -2.1  3.7
DATA[,2]
## [1]  0.7 -0.9  1.2 -2.1  3.7
DATA[,"b"]
## [1]  0.7 -0.9  1.2 -2.1  3.7
```

- 透過新的索引函數「$」，我們將可以為資料表新增變數，注意新增變數功能沒有辦法透過舊的索引函數做到：

```
a = c(TRUE, FALSE, TRUE, FALSE, FALSE)
b = c(0.7, -0.9, 1.2, -2.1, 3.7)
c = c("A", "B", "C", "C", "B")
DATA = data.frame(a, b, c)
DATA
##       a    b c
## 1  TRUE  0.7 A
## 2 FALSE -0.9 B
## 3  TRUE  1.2 C
## 4 FALSE -2.1 C
## 5 FALSE  3.7 B
DATA$d = c(1, 5, 8, 9, 12)
DATA
##       a    b c  d
## 1  TRUE  0.7 A  1
## 2 FALSE -0.9 B  5
## 3  TRUE  1.2 C  8
## 4 FALSE -2.1 C  9
## 5 FALSE  3.7 B 12
```

- 除此之外，擴充陣列層的物件還可以透過函數「rbind()」及「cbind()」完成：

```
x = 1:4
X = matrix(x, nrow = 2, ncol = 2)
y = 2:5
Y = matrix(y, nrow = 2, ncol = 2)

rbind(X, Y)
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## [3,]    2    4
## [4,]    3    5
rbind(Y, X)
##      [,1] [,2]
## [1,]    2    4
## [2,]    3    5
## [3,]    1    3
## [4,]    2    4
cbind(X, Y)
##      [,1] [,2] [,3] [,4]
## [1,]    1    3    2    4
## [2,]    2    4    3    5
```

- 還記得如何擴充向量嗎？

```
x = 1:4
y = 6:8

# 問題，如何合併它們並儲存成物件z呢？
```

# 讀取資料表(1)

- 做為一個統計程式語言，R支援了多種額外的功能統計檢定功能，但在執行這些功能的第一步，是要將檔案讀進R的工作環境裡面。
- 請按[這裡](https://linchin.ndmctsgh.edu.tw/data/monitoring_1.csv)下載等等要讀取的檔案

– 這個檔案是105年4月25日早上5點30台北市各監測站各空氣汙染物濃度的檔案。

- 我建議任何資料在讀進R之前盡量先轉成csv檔，在Excel中可以輕易的另存新檔成csv檔

– 使用函數「read.csv()」讀取csv檔

```
dat = read.csv("monitoring_1.csv", header = TRUE, fileEncoding = 'CP950') #請將路徑改為自己放置的位置
```

- 請注意，在這邊我們第一次面對到這種比較複雜的函數，注意到上面那串程式碼在小括號內有一個【header = TRUE】的指令，他是在說讀取檔案時，該檔案的首列為『欄位名稱』。
- 由於之後面對的函數可能會有極多的input，因此要查看這些函數能更改什麼參數的時候，可以使用函數「help()」

```
help(read.csv)
?read.csv #也可以這樣查詢
```

- 由於讀進來的資料表被儲存為物件「dat」，之前我們學過函數「class()」可以用來確認物件格式，我們可以來看看讀進來的是否為資料表(data.frame)格式

```
class(dat)
## [1] "data.frame"
```

# 讀取資料表(2)

- 檔案讀取後，我們會在Rstudio右上角的Environment中發現dat這個物件。雖然檔案已經成功讀進來了，但是我們並不清楚這個檔案在R裡面長成甚麼樣子，我們可以利用下列幾個函數做基本的判斷

1. 函數「head()」可以查看資料表的前6列
2. 函數「summary()」可以查看此資料表大致的資料結構

```
head(dat)
##                  time    device_id s_d0  s_t0 s_h0      lat      lon   school
## 1 2016-04-25 04:42:16 28C2DDDD4505   17 29.75   77 24.99643 121.5483 景興國小
## 2 2016-04-25 05:25:11 28C2DDDD450C   27 27.50   87 25.05221 121.5637 西松國小
## 3 2016-04-25 05:23:57 28C2DDDD4534   27 30.00   65 25.08374 121.5070 葫蘆國小
## 4 2016-04-25 05:25:13 28C2DDDD47C6   30 26.12   93 25.01992 121.5305 溫州國宅
## 5 2016-04-25 05:24:48 28C2DDDD4234   30 28.00   83 25.00244 121.5519 興隆國小
## 6 2016-04-25 05:24:48 28C2DDDD4234   30 28.00   83 25.00244 121.5519 興隆國小
##            time2
## 1 2016/4/25 5:30
## 2 2016/4/25 5:30
## 3 2016/4/25 5:30
## 4 2016/4/25 5:30
## 5 2016/4/25 5:30
## 6 2016/4/25 5:30
summary(dat)
##                   time           device_id       s_d0            s_t0      
##  2016-04-25 05:23:46: 2   28C2DDDD41FA: 2   Min.   :17.00   Min.   :26.12  
##  2016-04-25 05:24:00: 2   28C2DDDD4234: 2   1st Qu.:31.50   1st Qu.:27.75  
##  2016-04-25 05:24:48: 2   28C2DDDD400A: 1   Median :35.50   Median :28.00  
##  2016-04-25 04:42:16: 1   28C2DDDD41B2: 1   Mean   :34.86   Mean   :28.10  
##  2016-04-25 05:23:45: 1   28C2DDDD41C0: 1   3rd Qu.:38.25   3rd Qu.:28.53  
##  2016-04-25 05:23:54: 1   28C2DDDD41EB: 1   Max.   :43.00   Max.   :30.00  
##  (Other)            :19   (Other)     :20                                  
##       s_h0             lat             lon             school  
##  Min.   : 65.00   Min.   :24.99   Min.   :121.5   民生國小: 2  
##  1st Qu.: 84.00   1st Qu.:25.03   1st Qu.:121.5   興隆國小: 2  
##  Median : 88.00   Median :25.05   Median :121.5   仁愛國小: 1  
##  Mean   : 89.39   Mean   :25.05   Mean   :121.5   內湖國小: 1  
##  3rd Qu.: 89.75   3rd Qu.:25.07   3rd Qu.:121.6   南湖國小: 1  
##  Max.   :151.00   Max.   :25.13   Max.   :121.6   古亭國小: 1  
##                                                   (Other) :20  
##             time2   
##  2016/4/25 5:30:28  
##                     
##                     
##                     
##                     
##                     
##
```

用到一個新函數「%in%」，它的功能是確認左邊的物件是否有在右邊的物件中出現過，如下

```
dat[5,"school"] 
## [1] 興隆國小
## 26 Levels: 仁愛國小 內湖國小 南湖國小 古亭國小 ... 西門國小
dat[1:4,"school"]
## [1] 景興國小 西松國小 葫蘆國小 溫州國宅
## 26 Levels: 仁愛國小 內湖國小 南湖國小 古亭國小 ... 西門國小
dat[5,"school"] %in% dat[1:4,"school"]
## [1] FALSE
dat[6,"school"] 
## [1] 興隆國小
## 26 Levels: 仁愛國小 內湖國小 南湖國小 古亭國小 ... 西門國小
dat[1:5,"school"]
## [1] 景興國小 西松國小 葫蘆國小 溫州國宅 興隆國小
## 26 Levels: 仁愛國小 內湖國小 南湖國小 古亭國小 ... 西門國小
dat[6,"school"] %in% dat[1:5,"school"]
## [1] TRUE
```

- 資料表可以透過索引函數「$」新增變數嗎：

```
dat$DUP = FALSE # 也可以用「dat[,'DUP'] = FALSE」新增

for (i in 2:nrow(dat)) {
  dat[i,'DUP'] = dat[i,"school"]  %in% dat[1:(i-1),"school"]
}

head(dat)
##                  time    device_id s_d0  s_t0 s_h0      lat      lon   school
## 1 2016-04-25 04:42:16 28C2DDDD4505   17 29.75   77 24.99643 121.5483 景興國小
## 2 2016-04-25 05:25:11 28C2DDDD450C   27 27.50   87 25.05221 121.5637 西松國小
## 3 2016-04-25 05:23:57 28C2DDDD4534   27 30.00   65 25.08374 121.5070 葫蘆國小
## 4 2016-04-25 05:25:13 28C2DDDD47C6   30 26.12   93 25.01992 121.5305 溫州國宅
## 5 2016-04-25 05:24:48 28C2DDDD4234   30 28.00   83 25.00244 121.5519 興隆國小
## 6 2016-04-25 05:24:48 28C2DDDD4234   30 28.00   83 25.00244 121.5519 興隆國小
##            time2   DUP
## 1 2016/4/25 5:30 FALSE
## 2 2016/4/25 5:30 FALSE
## 3 2016/4/25 5:30 FALSE
## 4 2016/4/25 5:30 FALSE
## 5 2016/4/25 5:30 FALSE
## 6 2016/4/25 5:30  TRUE
```

# 簡單資料清理及寫出檔案(1)

- 事實上，剛剛我們需要的功能在R裡面可以用很簡單的函數做到，因此從這裡開始我們要開始學習大量的函數，但同學一定要了解就算你不知道這些函數，也可以用迴圈暴力做完每一件事情

– 函數「duplicated()」可以直接找尋整個資料表是否有重複的列

```
dat$DUP1 = duplicated(dat)
dat[,c("school", "DUP1")]
##                      school  DUP1
## 1                  景興國小 FALSE
## 2                  西松國小 FALSE
## 3                  葫蘆國小 FALSE
## 4                  溫州國宅 FALSE
## 5                  興隆國小 FALSE
## 6                  興隆國小 FALSE
## 7                  萬大國小 FALSE
## 8                  舊莊國小 FALSE
## 9  台北市立大學附設實驗國小 FALSE
## 10                 古亭國小 FALSE
## 11                 永建國小 FALSE
## 12                 福林國小 FALSE
## 13                 清江國小 FALSE
## 14                 富安國小 FALSE
## 15                 敦化國小 FALSE
## 16                 潭美國小 FALSE
## 17                 西門國小 FALSE
## 18                 仁愛國小 FALSE
## 19                 文湖國小 FALSE
## 20                 大佳國小 FALSE
## 21                 吉林國小 FALSE
## 22                 懷生國小 FALSE
## 23                 大同國小 FALSE
## 24                 內湖國小 FALSE
## 25                 民生國小 FALSE
## 26                 立農國小 FALSE
## 27                 民生國小 FALSE
## 28                 南湖國小 FALSE
```

- 也可以直接檢查單一變數是否重複

```
dat$DUP2 = duplicated(dat$school)
dat[,c("school", "DUP1", "DUP2")]
##                      school  DUP1  DUP2
## 1                  景興國小 FALSE FALSE
## 2                  西松國小 FALSE FALSE
## 3                  葫蘆國小 FALSE FALSE
## 4                  溫州國宅 FALSE FALSE
## 5                  興隆國小 FALSE FALSE
## 6                  興隆國小 FALSE  TRUE
## 7                  萬大國小 FALSE FALSE
## 8                  舊莊國小 FALSE FALSE
## 9  台北市立大學附設實驗國小 FALSE FALSE
## 10                 古亭國小 FALSE FALSE
## 11                 永建國小 FALSE FALSE
## 12                 福林國小 FALSE FALSE
## 13                 清江國小 FALSE FALSE
## 14                 富安國小 FALSE FALSE
## 15                 敦化國小 FALSE FALSE
## 16                 潭美國小 FALSE FALSE
## 17                 西門國小 FALSE FALSE
## 18                 仁愛國小 FALSE FALSE
## 19                 文湖國小 FALSE FALSE
## 20                 大佳國小 FALSE FALSE
## 21                 吉林國小 FALSE FALSE
## 22                 懷生國小 FALSE FALSE
## 23                 大同國小 FALSE FALSE
## 24                 內湖國小 FALSE FALSE
## 25                 民生國小 FALSE FALSE
## 26                 立農國小 FALSE FALSE
## 27                 民生國小 FALSE  TRUE
## 28                 南湖國小 FALSE FALSE
```

- 一個一個檢查DUP1與DUP2是否相同有點白痴，這時候我們可以用函數「all.equal」

```
all.equal(dat$DUP1, dat$DUP2)
## [1] "2 element mismatches"
```

# 簡單資料清理及寫出檔案(2)

- 現在，我們會希望把重複的列刪除掉，這時候我們可以使用索引函數做到。

– 由於我們已經創造了一個新變數「DUP」，若他為FALSE就是唯一的個案，TRUE的就是重複的

```
dat.clean = dat[dat$DUP1==FALSE,]
```

- 現在，我們已經可以透過函數「write.csv」將清理過的檔案寫出了。

```
write.csv(dat.clean, "monitoring_clean.csv", fileEncoding = 'CP950')
```

# Ch 04 自訂函數與資料整理

# 自訂函數(1)

- 目前我們已經學會了許多基本的R語言技巧，但我們慢慢發現我們想做的事情往往需要好幾行程式碼才能達到，我們有沒有可能簡化他呢?

– 自訂函數是一個組合複雜算式的好方法，舉例來說我們經常想要對學生的成績做加分，最常用的手段是「開根號乘以10」，我們可以把函數寫成這樣：

```
add_score = function (x) {
  sqrt(x)*10
}

add_score(36)
## [1] 60
add_score(58)
## [1] 76.15773
```

# 自訂函數(2)

- 複習一下我們第二節課教到費波納奇數列，他的做法如下：

```
x = c(1, 1)

for (i in 3:20) {
  x[i] = x[i-1] + x[i-2]
}

x
##  [1]    1    1    2    3    5    8   13   21   34   55   89  144  233  377  610
## [16]  987 1597 2584 4181 6765
```

- 仔細觀察一下我們的程式，其中20是個可變的數字，我們將其拉到最外面

```
last.seq = 20
```

- 這樣是不是就可以整合成一個函數了?

```
Fibonacci = function (last.seq) {
  x = c(1, 1)

  for (i in 3:last.seq) {
    x[i] = x[i-1] + x[i-2]
  }

  x
}

Fibonacci(10)
##  [1]  1  1  2  3  5  8 13 21 34 55
Fibonacci(20)
##  [1]    1    1    2    3    5    8   13   21   34   55   89  144  233  377  610
## [16]  987 1597 2584 4181 6765
```

- 是不是方便多了?

# 自訂函數(3)

- 另外，假定我們希望擴展費波納奇數列，讓使用者指定起始值，自訂函數也能允許這樣的功能：

```
Fibonacci = function (a, b, last.seq) {
  x = c(a, b)

  for (i in 3:last.seq) {
    x[i] = x[i-1] + x[i-2]
  }

  x
}

Fibonacci(1, 1, 20)
##  [1]    1    1    2    3    5    8   13   21   34   55   89  144  233  377  610
## [16]  987 1597 2584 4181 6765
Fibonacci(-3, 2, 20)
##  [1]  -3   2  -1   1   0   1   1   2   3   5   8  13  21  34  55  89 144 233 377
## [20] 610
```

# 自訂函數(4)

- 顯然，在剛剛的函數中，當 last.seq < 3 時會產生錯誤

```
Fibonacci(2, 4, 2)
```

- 所以，我們需要在函數中加入確認length大小而避免錯誤

– 不要忘記函數「cat()」能與使用者溝通

```
Fibonacci = function (a, b, last.seq) {
  if (last.seq < 3) {
    cat("last.seq必須大於等於3。")
  } else {
    x = c(a, b)
    
    for (i in 3:last.seq) {
      x[i] = x[i-1] + x[i-2]
    }
    
    x
  }
}
```

- 現在當last.seq < 3時就會提出警告

```
Fibonacci(2, 4, 2)
## last.seq必須大於等於3。
```

– 你也可以將函數「cat()」換成函數「message()」或是函數「stop()」試試看

# 合併資料(1)

- 現在讓我們回到上節課所處理的資料檔，這份資料檔最討厭的地方是經常會有重複，所以我們可以使用自訂函數將整個資料整理的過程給打包起來：
- 請按[這裡](https://linchin.ndmctsgh.edu.tw/data/monitoring_1.csv)下載上週的檔案

– 這是那些測站在早上5點半的時候所測得的汙染物濃度

- 這是原始的處理程式碼：

```
dat1 = read.csv("monitoring_1.csv", header = TRUE, fileEncoding = 'CP950')
dat1.clean = dat1[duplicated(dat1) == FALSE,]
dat1.clean
##                   time    device_id s_d0  s_t0 s_h0      lat      lon
## 1  2016-04-25 04:42:16 28C2DDDD4505   17 29.75   77 24.99643 121.5483
## 2  2016-04-25 05:25:11 28C2DDDD450C   27 27.50   87 25.05221 121.5637
## 3  2016-04-25 05:23:57 28C2DDDD4534   27 30.00   65 25.08374 121.5070
## 4  2016-04-25 05:25:13 28C2DDDD47C6   30 26.12   93 25.01992 121.5305
## 5  2016-04-25 05:24:48 28C2DDDD4234   30 28.00   83 25.00244 121.5519
## 7  2016-04-25 05:24:04 28C2DDDD455E   30 28.12   96 25.02298 121.4993
## 8  2016-04-25 05:24:47 28C2DDDD4414   32 26.50   95 25.04024 121.6195
## 9  2016-04-25 05:25:16 28C2DDDD4588   33 27.75   88 25.03579 121.5135
## 10 2016-04-25 05:24:42 28C2DDDD41C0   33 27.87  100 25.02058 121.5288
## 11 2016-04-25 05:23:54 28C2DDDD4357   33 28.12   92 24.98758 121.5500
## 12 2016-04-25 05:25:51 28C2DDDD459A   34 27.87   84 25.09869 121.5296
## 13 2016-04-25 05:23:45 28C2DDDD4246   34 29.37   86 25.12696 121.5077
## 14 2016-04-25 05:25:12 28C2DDDD45A1   35 28.50   89 25.10584 121.4826
## 15 2016-04-25 05:24:16 28C2DDDD400A   36 28.62   83 25.04922 121.5486
## 16 2016-04-25 05:24:40 28C2DDDD4372   36 29.12   84 25.06035 121.5906
## 17 2016-04-25 05:23:46 28C2DDDD423E   37 27.25   89 25.04317 121.5036
## 18 2016-04-25 05:23:46 28C2DDDD456A   37 27.87   89 25.03577 121.5524
## 19 2016-04-25 05:24:44 28C2DDDD4790   38 27.00  100 25.08577 121.5601
## 20 2016-04-25 05:25:44 28C2DDDD41B2   38 28.00   86 25.07329 121.5364
## 21 2016-04-25 05:26:20 28C2DDDD458F   38 28.62   87 25.05472 121.5296
## 22 2016-04-25 05:26:30 28C2DDDD434F   39 29.37   75 25.04524 121.5418
## 23 2016-04-25 05:25:38 28C2DDDD45A9   41 28.00  151 25.06528 121.5162
## 24 2016-04-25 05:25:32 28C2DDDD436D   42 27.62   89 25.07913 121.5802
## 25 2016-04-25 05:24:00 28C2DDDD41FA   42 27.75   88 25.05652 121.5522
## 26 2016-04-25 05:26:34 28C2DDDD41EB   42 27.75   88 25.11949 121.5050
## 28 2016-04-25 05:25:48 28C2DDDD434D   43 28.50   88 25.06870 121.6120
##                      school          time2
## 1                  景興國小 2016/4/25 5:30
## 2                  西松國小 2016/4/25 5:30
## 3                  葫蘆國小 2016/4/25 5:30
## 4                  溫州國宅 2016/4/25 5:30
## 5                  興隆國小 2016/4/25 5:30
## 7                  萬大國小 2016/4/25 5:30
## 8                  舊莊國小 2016/4/25 5:30
## 9  台北市立大學附設實驗國小 2016/4/25 5:30
## 10                 古亭國小 2016/4/25 5:30
## 11                 永建國小 2016/4/25 5:30
## 12                 福林國小 2016/4/25 5:30
## 13                 清江國小 2016/4/25 5:30
## 14                 富安國小 2016/4/25 5:30
## 15                 敦化國小 2016/4/25 5:30
## 16                 潭美國小 2016/4/25 5:30
## 17                 西門國小 2016/4/25 5:30
## 18                 仁愛國小 2016/4/25 5:30
## 19                 文湖國小 2016/4/25 5:30
## 20                 大佳國小 2016/4/25 5:30
## 21                 吉林國小 2016/4/25 5:30
## 22                 懷生國小 2016/4/25 5:30
## 23                 大同國小 2016/4/25 5:30
## 24                 內湖國小 2016/4/25 5:30
## 25                 民生國小 2016/4/25 5:30
## 26                 立農國小 2016/4/25 5:30
## 28                 南湖國小 2016/4/25 5:30
```

# 合併資料(2)

- 透過我們剛剛學的自訂函數功能，我們可以將這整個過程整合起來：

```
data_pipeline = function (file.path) {
  dat1 = read.csv(file.path, header = TRUE, fileEncoding = 'CP950')
  dat1.clean = dat1[duplicated(dat1) == FALSE,]
  dat1.clean
}

data1_clean <- data_pipeline("monitoring_1.csv")
head(data1_clean)
##                  time    device_id s_d0  s_t0 s_h0      lat      lon   school
## 1 2016-04-25 04:42:16 28C2DDDD4505   17 29.75   77 24.99643 121.5483 景興國小
## 2 2016-04-25 05:25:11 28C2DDDD450C   27 27.50   87 25.05221 121.5637 西松國小
## 3 2016-04-25 05:23:57 28C2DDDD4534   27 30.00   65 25.08374 121.5070 葫蘆國小
## 4 2016-04-25 05:25:13 28C2DDDD47C6   30 26.12   93 25.01992 121.5305 溫州國宅
## 5 2016-04-25 05:24:48 28C2DDDD4234   30 28.00   83 25.00244 121.5519 興隆國小
## 7 2016-04-25 05:24:04 28C2DDDD455E   30 28.12   96 25.02298 121.4993 萬大國小
##            time2
## 1 2016/4/25 5:30
## 2 2016/4/25 5:30
## 3 2016/4/25 5:30
## 4 2016/4/25 5:30
## 5 2016/4/25 5:30
## 7 2016/4/25 5:30
```

# 合併資料(3)

- 現在我們要做簡單的資料合併，首先請按[這裡](https://linchin.ndmctsgh.edu.tw/data/monitoring_2.csv)下載另外一個練習檔案

– 這是那些測站在早上7點的時候所測得的汙染物濃度

- 我們來利用剛剛的自訂函數直接處理

```
data2_clean <- data_pipeline("monitoring_2.csv")
head(data2_clean)
##                  time    device_id s_d0  s_t0 s_h0      lat      lon
## 1 2016-04-25 06:55:23 28C2DDDD4591   33 26.75   91 25.00070 121.5754
## 2 2016-04-25 06:55:28 28C2DDDD41EB   41 27.87   87 25.11949 121.5050
## 3 2016-04-25 06:55:36 28C2DDDD4598   41 28.50   88 25.06126 121.5111
## 4 2016-04-25 06:55:59 28C2DDDD452E   42 26.62   88 25.03944 121.5462
## 5 2016-04-25 06:56:04 28C2DDDD4372   42 28.75   85 25.06035 121.5906
## 6 2016-04-25 06:56:18 28C2DDDD4338   38 26.62   89 25.14918 121.5242
##             school          time2
## 1         博嘉國小 2016/4/25 7:00
## 2         立農國小 2016/4/25 7:00
## 3         永樂國小 2016/4/25 7:00
## 4 私立復興實驗中學 2016/4/25 7:00
## 5         潭美國小 2016/4/25 7:00
## 6         泉源國小 2016/4/25 7:00
```

# 合併資料(4)

- 現在，我們希望將早上7點的值與早上5點半的值做合併，此時需要一個新函數「merge()」，此函數能幫助我們把兩個檔案依據索引變數做擴增

– 下面是從路徑到合併檔案的全過程

```
data1_clean <- data_pipeline("monitoring_1.csv")
data2_clean <- data_pipeline("monitoring_2.csv")
merge.dat = merge(data1_clean, data2_clean, by = "school", all = TRUE)
head(merge.dat)
##                     school              time.x  device_id.x s_d0.x s_t0.x
## 1                 仁愛國小 2016-04-25 05:23:46 28C2DDDD456A     37  27.87
## 2                 內湖國小 2016-04-25 05:25:32 28C2DDDD436D     42  27.62
## 3                 南湖國小 2016-04-25 05:25:48 28C2DDDD434D     43  28.50
## 4                 古亭國小 2016-04-25 05:24:42 28C2DDDD41C0     33  27.87
## 5 台北市立大學附設實驗國小 2016-04-25 05:25:16 28C2DDDD4588     33  27.75
## 6                 吉林國小 2016-04-25 05:26:20 28C2DDDD458F     38  28.62
##   s_h0.x    lat.x    lon.x        time2.x              time.y  device_id.y
## 1     89 25.03577 121.5524 2016/4/25 5:30 2016-04-25 06:58:42 28C2DDDD456A
## 2     89 25.07913 121.5802 2016/4/25 5:30 2016-04-25 06:56:22 28C2DDDD436D
## 3     88 25.06870 121.6120 2016/4/25 5:30                <NA>         <NA>
## 4    100 25.02058 121.5288 2016/4/25 5:30                <NA>         <NA>
## 5     88 25.03579 121.5135 2016/4/25 5:30                <NA>         <NA>
## 6     87 25.05472 121.5296 2016/4/25 5:30                <NA>         <NA>
##   s_d0.y s_t0.y s_h0.y    lat.y    lon.y        time2.y
## 1     39  28.00     87 25.03577 121.5524 2016/4/25 7:00
## 2     40  27.12     90 25.07913 121.5802 2016/4/25 7:00
## 3     NA     NA     NA       NA       NA           <NA>
## 4     NA     NA     NA       NA       NA           <NA>
## 5     NA     NA     NA       NA       NA           <NA>
## 6     NA     NA     NA       NA       NA           <NA>
```

# 初級資料轉換(1)

- 請在[這裡](https://linchin.ndmctsgh.edu.tw/data/comorbidity_1.csv)下載一份範例資料

– 這份資料是描述每個人疾病狀況的檔案，我們希望將這份直式資料轉為橫式資料

```
dat = read.csv("comorbidity_1.csv", header = TRUE, fileEncoding = 'CP950')
head(dat, 10)
##    ID Disease
## 1   n     CKD
## 2   f      DM
## 3   m     HTN
## 4   w      DM
## 5   u      DM
## 6   j     HTN
## 7   d     CKD
## 8   l     CKD
## 9   y     HTN
## 10  w     HTN
```

- 我們的目標是將檔案轉換成這樣的格式

```
##   ID   CKD Depression    DM   HTN
## 1  a  TRUE       TRUE  TRUE  TRUE
## 2  b  TRUE       TRUE  TRUE FALSE
## 3  c FALSE       TRUE  TRUE FALSE
## 4  d  TRUE      FALSE FALSE  TRUE
## 5  e  TRUE       TRUE FALSE FALSE
## 6  f  TRUE      FALSE  TRUE  TRUE
```

# 初級資料轉換(2)

- 這是我們第一次面對到比較複雜的案例，在開始之前我們要做的是先思考怎樣能達到我們想要的效果。

– 請各位先回想在前面幾節課學過哪些函數、功能？我保證只使用已經學會的功能就足以應付這個問題了。

1. 函數「length()」
2. 函數「levels()」
3. 各式索引函數
4. 迴圈函數「for」
5. …

# 初級資料轉換(3)

- 在最開始的時候，我們要先對這份資料表做初步分析。這份資料表有幾個人？有幾種可能的疾病？
- 我們很明顯是需要用到函數「levels()」以及函數「length()」的組合

– 而函數「levels()」僅能用在因子向量上，所以我們要先確認ID及Disease的屬性

```
class(dat[,1])
## [1] "factor"
class(dat[,2])
## [1] "factor"
```

– 很幸運的，在檔案讀進來的時候兩者就都已經是因子向量了，如果不是的話，記得要使用函數「as.factor()」進行轉換

```
dat[,1] = as.factor(dat[,1])
dat[,2] = as.factor(dat[,2])
```

- 接著，我們就能用函數「levels()」取得檔案中所有曾經出現過的人，以及所有曾經出現過的疾病

```
levels.sample = levels(dat[,1])
levels.sample
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "p" "r" "s" "t" "u"
## [20] "v" "w" "x" "y" "z"
n.sample = length(levels.sample)
n.sample
## [1] 24
levels.disease = levels(dat[,2])
levels.disease
## [1] "CKD"        "Depression" "DM"         "HTN"
n.disease = length(levels.disease)
n.disease
## [1] 4
```

# 初級資料轉換(4)

- 我們發現共有24個人，總共有4種疾病，因此我們想要創造一個24*5的矩陣，其中第一欄放ID，其他欄位分別描述4種疾病的狀態

– 這裡我們會用到函數「matrix」做一個空的矩陣，在最開始的時候我們可以先在矩陣內都填上0(填什麼並不重要，因為等等都會覆蓋掉)

```
new.dat = matrix(0, nrow = n.sample, ncol = n.disease+1)
colnames(new.dat) = c("ID", levels.disease)
new.dat[,1] = levels.sample
new.dat
##       ID  CKD Depression DM  HTN
##  [1,] "a" "0" "0"        "0" "0"
##  [2,] "b" "0" "0"        "0" "0"
##  [3,] "c" "0" "0"        "0" "0"
##  [4,] "d" "0" "0"        "0" "0"
##  [5,] "e" "0" "0"        "0" "0"
##  [6,] "f" "0" "0"        "0" "0"
##  [7,] "g" "0" "0"        "0" "0"
##  [8,] "h" "0" "0"        "0" "0"
##  [9,] "i" "0" "0"        "0" "0"
## [10,] "j" "0" "0"        "0" "0"
## [11,] "k" "0" "0"        "0" "0"
## [12,] "l" "0" "0"        "0" "0"
## [13,] "m" "0" "0"        "0" "0"
## [14,] "n" "0" "0"        "0" "0"
## [15,] "p" "0" "0"        "0" "0"
## [16,] "r" "0" "0"        "0" "0"
## [17,] "s" "0" "0"        "0" "0"
## [18,] "t" "0" "0"        "0" "0"
## [19,] "u" "0" "0"        "0" "0"
## [20,] "v" "0" "0"        "0" "0"
## [21,] "w" "0" "0"        "0" "0"
## [22,] "x" "0" "0"        "0" "0"
## [23,] "y" "0" "0"        "0" "0"
## [24,] "z" "0" "0"        "0" "0"
```

# 初級資料轉換(5)

- 接著，如果我們想要了解第一個人有哪些疾病，我們需要在原始檔中使用索引函數找到與他有關的資料

```
i = 1
dat[dat[,1]==levels.sample[i],]
##    ID    Disease
## 11  a         DM
## 18  a        CKD
## 45  a Depression
## 49  a        HTN
```

- 但是我們可能只對其中疾病的部分有興趣而已，所以我們在逗點的右邊也要加上數字

```
dat[dat[,1]==levels.sample[i],2]
## [1] DM         CKD        Depression HTN       
## Levels: CKD Depression DM HTN
```

- 這個人所有疾病通通都有，真是不走運，這時候我們又要用到函數「%in%」，它的功能是確認左邊的物件是否有在右邊的物件中出現過

```
levels.disease %in% dat[dat[,1]==levels.sample[i],2]
## [1] TRUE TRUE TRUE TRUE
```

- 接著，我們要把這4個值填入矩陣的第1列，但第一欄除外(因為第一欄是ID)，我們可以使用負數代表除去不想要的欄位

```
new.dat[i,-1] = levels.disease %in% dat[dat[,1]==levels.sample[i],2]
new.dat
##       ID  CKD    Depression DM     HTN   
##  [1,] "a" "TRUE" "TRUE"     "TRUE" "TRUE"
##  [2,] "b" "0"    "0"        "0"    "0"   
##  [3,] "c" "0"    "0"        "0"    "0"   
##  [4,] "d" "0"    "0"        "0"    "0"   
##  [5,] "e" "0"    "0"        "0"    "0"   
##  [6,] "f" "0"    "0"        "0"    "0"   
##  [7,] "g" "0"    "0"        "0"    "0"   
##  [8,] "h" "0"    "0"        "0"    "0"   
##  [9,] "i" "0"    "0"        "0"    "0"   
## [10,] "j" "0"    "0"        "0"    "0"   
## [11,] "k" "0"    "0"        "0"    "0"   
## [12,] "l" "0"    "0"        "0"    "0"   
## [13,] "m" "0"    "0"        "0"    "0"   
## [14,] "n" "0"    "0"        "0"    "0"   
## [15,] "p" "0"    "0"        "0"    "0"   
## [16,] "r" "0"    "0"        "0"    "0"   
## [17,] "s" "0"    "0"        "0"    "0"   
## [18,] "t" "0"    "0"        "0"    "0"   
## [19,] "u" "0"    "0"        "0"    "0"   
## [20,] "v" "0"    "0"        "0"    "0"   
## [21,] "w" "0"    "0"        "0"    "0"   
## [22,] "x" "0"    "0"        "0"    "0"   
## [23,] "y" "0"    "0"        "0"    "0"   
## [24,] "z" "0"    "0"        "0"    "0"
```